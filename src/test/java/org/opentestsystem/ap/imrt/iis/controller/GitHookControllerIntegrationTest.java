package org.opentestsystem.ap.imrt.iis.controller;

import org.junit.After;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iis.BaseIntegrationTest;
import org.opentestsystem.ap.imrt.iis.client.GitlabHookClient;
import org.opentestsystem.ap.imrt.iis.service.OperationalEventService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import javax.servlet.http.HttpServletRequest;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

public class GitHookControllerIntegrationTest extends BaseIntegrationTest {

    @Autowired
    private OperationalEventService operationalEventService;

    @Autowired
    GitlabHookClient gitlabHookClient;

    @After
    public void cleanup() {
        // Since we are messing with the mocks during testing, reset them when we are done
        reset(gitlabHookClient);
        reset(operationalEventService);
    }

    @Test
    public void testSystemHook() throws Exception {
        sendRequestAndCheckReply("/systemHook", HttpStatus.OK);
        verify(gitlabHookClient, times(1)).handleSystemHook(any(HttpServletRequest.class));

        // Now the same thing, but throw an exception
        RuntimeException e = new RuntimeException("Test");
        doThrow(e).when(gitlabHookClient).handleSystemHook(any(HttpServletRequest.class));
        sendRequestAndCheckReply("/systemHook", HttpStatus.INTERNAL_SERVER_ERROR);
        verify(gitlabHookClient, times(2)).handleSystemHook(any(HttpServletRequest.class));
        verify(operationalEventService, times(1)).serviceError(any(), eq(e), any());
    }

    @Test
    public void testWebHook() throws Exception {
        sendRequestAndCheckReply("/webHook", HttpStatus.OK);
        verify(gitlabHookClient, times(1)).handleWebHook(any(HttpServletRequest.class));

        // Now the same thing, but throw an exception
        RuntimeException e = new RuntimeException("Test");
        doThrow(e).when(gitlabHookClient).handleWebHook(any(HttpServletRequest.class));
        sendRequestAndCheckReply("/webHook", HttpStatus.INTERNAL_SERVER_ERROR);
        verify(gitlabHookClient, times(2)).handleWebHook(any(HttpServletRequest.class));
        verify(operationalEventService, times(1)).serviceError(any(), eq(e), any());
    }

    /**
     * Send a REST API request and validate the respone code
     * @param path  URI of request
     * @param expectedStatus  expected return status
     * @throws Exception From the MockMvc call
     */
    private void sendRequestAndCheckReply(String path, HttpStatus expectedStatus) throws Exception {
        mvc.perform(MockMvcRequestBuilders.get(path).accept(MediaType.APPLICATION_JSON))
                .andExpect(status().is(expectedStatus.value()));

    }
}
