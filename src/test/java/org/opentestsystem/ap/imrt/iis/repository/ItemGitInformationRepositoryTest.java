package org.opentestsystem.ap.imrt.iis.repository;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformationBuilder;
import org.opentestsystem.ap.imrt.common.repository.ImrtItemRepository;
import org.opentestsystem.ap.imrt.iis.BaseIntegrationTest;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class ItemGitInformationRepositoryTest extends BaseIntegrationTest {

    @Autowired
    ItemGitInformationRepository itemGitInformationRepository;

    @Autowired
    ImrtItemRepository imrtItemRepository;

    private ImrtItem imrtItem = null;

    @Before
    public void createItem() {
        // create an item in the DB, for our foreign key constraint
        imrtItem = new TestImrtItemBuilder().build();
        imrtItem = imrtItemRepository.save(imrtItem);
    }

    @Test
    public void shouldCreateItemGit() {
        // Create the itemGit
        ItemGitInformation itemGit = generateTestItemGitInformation(9);
        itemGit = itemGitInformationRepository.save(itemGit);
        // If we do a read, we should get back a new object with the same fields
        assertThat(itemGit).isEqualToComparingFieldByFieldRecursively(itemGitInformationRepository.findOne(9));
    }

    @Test
    public void shouldUpdateItemGit() {
        // Create the itemGit
        ItemGitInformation itemGit = generateTestItemGitInformation(13);
        itemGit = itemGitInformationRepository.save(itemGit);
        Instant originalUpdatedAt = imrtItem.getUpdatedAt();

        ItemGitInformation updated = itemGitInformationRepository.findOne(13);
        updated.setCurrentCommitHash("new commit hash");
        itemGitInformationRepository.save(updated);
        // There should still be only one row in the DB after the update
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(1);
        // If we do a read, we should get back a new object with the updated fields
        // Updated at will be later
        ItemGitInformation readItemGit = itemGitInformationRepository.findOne(13);
        assertThat(originalUpdatedAt).isBefore(readItemGit.getUpdatedAt());
        assertThat(updated.getCurrentCommitHash()).isEqualTo(readItemGit.getCurrentCommitHash());
        assertThat(itemGit.getProjectPath()).isEqualTo(readItemGit.getProjectPath());
    }

    @Test
    public void shouldDeleteItemGit() {
        ItemGitInformation itemGit = generateTestItemGitInformation(11);
        // Save to the DB
        itemGitInformationRepository.save(itemGit);
        // There should be one row in the DB after the save
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(1);
        itemGitInformationRepository.delete(11);
        // There should be no rows in the DB after the delete
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(0);
    }

    /**
     * Generate a fully populated ItemGitInformation for use in testing
     * @param projectId projectId
     * @return fully populated ItemGitInformation object
     */
    private ItemGitInformation generateTestItemGitInformation(int projectId) {
        return new ItemGitInformationBuilder()
                .withProjectId(projectId)
                .withImrtItem(imrtItem)
                .withProjectPath("test path")
                .withCurrentCommitHash("test hash")
                .withCurrentCommitDate(Instant.now())
                .withUpdatedBy("you")
                .build();

    }
}
