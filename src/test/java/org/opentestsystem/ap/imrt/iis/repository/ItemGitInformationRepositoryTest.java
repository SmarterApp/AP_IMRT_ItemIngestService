package org.opentestsystem.ap.imrt.iis.repository;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iis.BaseIntegrationTest;
import org.opentestsystem.ap.imrt.iis.model.ImrtItem;
import org.opentestsystem.ap.imrt.iis.model.ItemGitInformation;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;

public class ItemGitInformationRepositoryTest extends BaseIntegrationTest {
    private static final Logger logger = LoggerFactory.getLogger(ItemGitInformationRepositoryTest.class);

    @Autowired
    ItemGitInformationRepository itemGitInformationRepository;

    @Autowired
    ImrtItemRepository imrtItemRepository;

    private ImrtItem imrtItem = null;

    @Before
    public void createItem() {
        // create an item in the DB, for our foreign key constraint
        imrtItem = new ImrtItemBuilder().build();
        imrtItem = imrtItemRepository.save(imrtItem);
    }

    @Test
    public void shouldCreateItemGit() {
        // Create the itemGit
        ItemGitInformation itemGit = new ItemGitInformationBuilder()
                .withProjectId(9)
                .withImrtItem(imrtItem)
                .build();
        itemGit = itemGitInformationRepository.save(itemGit);
        // If we do a read, we should get back a new object with the same fields
        assertThat(itemGit).isEqualToComparingFieldByFieldRecursively(itemGitInformationRepository.findOne(9));
    }

    @Test
    public void shouldUpdateItemGit() {
        // Create the itemGit
        ItemGitInformation itemGit = new ItemGitInformationBuilder()
                .withProjectId(13)
                .withImrtItem(imrtItem)
                .build();
        itemGit = itemGitInformationRepository.save(itemGit);
        Instant originalUpdatedAt = imrtItem.getUpdatedAt();

        ItemGitInformation updated = itemGitInformationRepository.findOne(13);
        updated.setCurrentCommitHash("new commit hash");
        itemGitInformationRepository.save(updated);
        // There should still be only one row in the DB after the update
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(1);
        // If we do a read, we should get back a new object with the updated fields
        // Updated at will be later
        ItemGitInformation readItemGit = itemGitInformationRepository.findOne(13);
        assertThat(originalUpdatedAt).isBefore(readItemGit.getUpdatedAt());
        assertThat(updated.getCurrentCommitHash()).isEqualTo(readItemGit.getCurrentCommitHash());
        assertThat(itemGit.getProjectPath()).isEqualTo(readItemGit.getProjectPath());
    }

    @Test
    public void shouldDeleteItemGit() {
        ItemGitInformation itemGit = new ItemGitInformationBuilder()
                .withProjectId(11)
                .withImrtItem(imrtItem)
                .build();
        // Save to the DB
        itemGitInformationRepository.save(itemGit);
        // There should be one row in the DB after the save
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(1);
        itemGitInformationRepository.delete(11);
        // There should be no rows in the DB after the delete
        assertThat(itemGitInformationRepository.findAll().size()).isEqualTo(0);
    }
}
