package org.opentestsystem.ap.imrt.iis.service.impl;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.model.ItemName;
import org.opentestsystem.ap.common.rest.item.ItemCommitResponse;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.imrt.iis.builder.ImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.client.ItemEventListener;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemSynchronizationResponse;
import org.opentestsystem.ap.imrt.iis.service.ItemDeleteNotificationHandler;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.opentestsystem.ap.imrt.iis.service.ItemSynchronizationService;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

import java.util.Collections;
import java.util.Optional;
import java.util.UUID;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemSynchronizationServiceImplTest {
    @Mock
    private ItemEventListener mockItemEventListener;

    @Mock
    private OperationalEventService mockOperationalEventService;

    @Mock
    private ItemDeleteNotificationHandler mockItemDeleteNotificationHandler;

    @Mock
    private BaseItemRepository baseItemRepository;

    @Mock
    private ItemService itemService;

    private ItemBankProperties itemBankProperties = new ItemBankProperties();

    private ItemSynchronizationService itemSynchronizationService;

    @Before
    public void setup() {
        itemSynchronizationService = new ItemSynchronizationServiceImpl(
                mockItemEventListener,
                mockItemDeleteNotificationHandler,
                mockOperationalEventService,
                itemBankProperties,
                baseItemRepository,
                itemService);
    }

    @Test
    @Ignore
    public void shouldOnlyUpdateItem() {
        Pageable pageable = new PageRequest(0, 1);
        BaseItem item = new ImrtItemBuilder().build();
        UUID commitId = UUID.randomUUID();
        item.setCommitId(commitId);
        PageImpl<BaseItem> page = new PageImpl<>(Collections.singletonList(item), pageable, 1);
        ItemName name = new ItemName();
        name.setId(1);

        ItemEntityResponse response = new ItemEntityResponse();
        response.setId(commitId);

        when(itemService.getItemIdsInItemBank()).thenReturn(Collections.singletonList(String.valueOf(item.getId())));
        when(itemService.findLatestItemEntityByItemId(item.getId())).thenReturn(Optional.of(response));
        when(itemService.findItemEntityById(commitId)).thenReturn(Optional.of(response));
        when(baseItemRepository.findById(item.getId())).thenReturn(item);
        when(baseItemRepository.findAll(isA(PageRequest.class)))
                .thenReturn(page)
                .thenReturn(new PageImpl<>(Collections.emptyList()));

        final ItemSynchronizationResponse syncResponse = itemSynchronizationService.synchronize();

        verify(mockItemEventListener).onSyncJobItem(123); // always call update
        verify(mockItemEventListener, never()).onDeleteItem(1); // since number of items in IMRT match number of items in source control, no delete should happen

        assertThat(syncResponse.getNumberOfItemsWithoutWebhook()).isEqualTo(0);
        assertThat(syncResponse.getNumberOfItemsDeletedFromImrt()).isEqualTo(0);
    }

    @Test
    @Ignore
    public void shouldDeleteAnItemThatExistsInImrtButNotSourceControl() {
        Pageable pageable = new PageRequest(0, 1);
        UUID commitId = UUID.randomUUID();
        BaseItem item = new ImrtItemBuilder().build();

        item.setCommitId(commitId);
        PageImpl<BaseItem> page = new PageImpl<>(Collections.singletonList(item), pageable, 1);
        ItemName name = new ItemName();
        name.setId(1);

        when(itemService.findLatestItemEntityByItemId(item.getId())).thenReturn(Optional.empty());
        when(itemService.findItemEntityById(commitId)).thenReturn(Optional.empty());

        when(baseItemRepository.findAll(isA(PageRequest.class)))
                .thenReturn(page)
                .thenReturn(new PageImpl<>(Collections.emptyList()));

        final ItemSynchronizationResponse syncResponse = itemSynchronizationService.synchronize();

        // since IMRT item 42 exists in IMRT but not in source control, item 42 should be deleted.
        verify(mockItemDeleteNotificationHandler).processItemMessage(item.getId());

        assertThat(syncResponse.getNumberOfItembankIds()).isEqualTo(0);
        assertThat(syncResponse.getNumberOfItemsWithoutWebhook()).isEqualTo(0);
        assertThat(syncResponse.getNumberOfItemsDeletedFromImrt()).isEqualTo(1);
    }

    @Test
    @Ignore
    public void shouldSyncSingleItemWithoutWebhook() {
        ItemCommitResponse response = new ItemCommitResponse("1", Collections.singletonList(UUID.randomUUID()));

        when(itemService.findAllCommits(1)).thenReturn(Optional.of(response));

        itemSynchronizationService.synchronizeItem(1);

        verify(mockItemEventListener).onSyncJobItem(1);
    }
}
