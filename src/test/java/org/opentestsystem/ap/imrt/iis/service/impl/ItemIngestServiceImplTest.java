package org.opentestsystem.ap.imrt.iis.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.ImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.core.ItemBankMapper;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemUpdateEvent;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionProcessor;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionService;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.opentestsystem.ap.imrt.iis.service.ItemWorkQueueService;
import org.opentestsystem.ap.imrt.iis.service.ProjectLockService;

import java.util.UUID;

import static org.junit.Assert.fail;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemIngestServiceImplTest {
    private static final int itemBankId = 432;
    private static final long lockId = 98765;

    @Mock
    private ProjectLockService projectLockService;

    @Mock
    private ItemRevisionService itemRevisionService;

    @Mock
    private OperationalEventService operationalEventService;

    @Mock
    private ItemRevisionProcessor businessRuleRunner;

    @Mock
    private ItemBankMapper itemConverter;

    @Mock
    private ItemWorkQueueService mockItemWorkQueueService;

    @Mock
    private ItemService itemService;

    @Mock
    private BaseItemRepository baseItemRepository;

    private ItemRevision itemRevision;

    private ItemIngestServiceImpl itemIngestService;

    @Before
    public void setup() {
        BaseItem baseItem = new ImrtItemBuilder()
                .withId(123)
                .withKey(1)
                .build();

        itemRevision = ItemRevision.builder()
                .withBaseItem(baseItem)
                .build();

        itemIngestService = new ItemIngestServiceImpl(projectLockService,
                itemRevisionService, operationalEventService, businessRuleRunner, itemConverter, mockItemWorkQueueService, itemService, baseItemRepository);
    }

    @Test
    public void shouldThrowNoLock() {
        ItemUpdateEvent itemUpdateEvent = new ItemUpdateEvent(itemBankId, UUID.randomUUID());
        when(projectLockService.lockProject(itemBankId)).thenThrow(new RuntimeException());
        try {
            itemIngestService.syncItem(itemUpdateEvent);
            fail();
        } catch (RuntimeException e) {
            verify(projectLockService).lockProject(itemBankId);
            verify(projectLockService, never()).unlockProject(anyInt(), anyLong());
        }
    }

    @Test
    public void shouldErrorHistoryThrows() {
        ItemUpdateEvent itemUpdateEvent = new ItemUpdateEvent(itemBankId, UUID.randomUUID());
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);

        try {
            itemIngestService.syncItem(itemUpdateEvent);
            fail();
        } catch (Throwable e) {
            verify(projectLockService).lockProject(itemBankId);
            verify(projectLockService).unlockProject(itemBankId, lockId);
        }
    }

    @Test
    public void shouldNotValidateItemIfCommitHashSame() {
//        ImrtItem imrtItem = new ImrtItemBuilder()
//                .withKey(3)
//                .withItemJson(new SaItem("12"))
//                .build();
//
//        ItemGitInformation existing = new TestItemGitBuilder()
//                .withImrtItem(imrtItem)
//                .withCurrentCommitHash("hash2")
//                .build();
//
//        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder()
//                .withRevisionId("hash")
//                .withItem(new StimItem("test stim"))
//                .build();
//
//        ItemBankItemRevision revision2 = new TestItemBankItemRevisionBuilder()
//                .withRevisionId("hash2")
//                .withItem(new StimItem("test stim"))
//                .build();
//
//        itemRevision = ItemRevision.builder()
//                .withBaseItem(imrtItem)
//                .withItemGitInformation(existing)
//                .withItemLog(new ItemLog())
//                .build();
//
//        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(revision));
//        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
//        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(existing);
//        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList(revision, revision2));
//
//        when(itemConverter.map(isA(ItemBankItemRevision.class), isA(ItemGitInformation.class))).thenReturn(itemRevision);
//
//        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(2, ItemRevision.class))
//                .when(businessRuleRunner)
//                .applyRules(eq(existing), any(Item.class), any(ItemRevision.class));
//
//        itemIngestService.syncItem(itemBankId);
//
//        verify(itemBankClient).getItemHistory(itemBankId, existing);
//        verify(projectLockService).lockProject(itemBankId);
//        verifyZeroInteractions(mockItemWorkQueueService);
//        verify(projectLockService).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitNoExisting() {
//        ItemBankItemRevision itemBankItemRevision = new TestItemBankItemRevisionBuilder()
//                .withRevisionId("hash1")
//                .withItem(new StimItem("test stim"))
//                .build();
//
//        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(itemBankItemRevision));
//        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
//        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(null);
//        when(itemBankClient.getItemHistory(itemBankId, null)).thenReturn(Lists.newArrayList(itemBankItemRevision));
//        when(itemConverter.map(isA(ItemBankItemRevision.class), isNull(ItemGitInformation.class))).thenReturn(itemRevision);
//
//        // When a new item is created in the DB, the key is set at that point. If we don't do this we have a NPE later
//        // when the code tries to access the key
//        doAnswer((InvocationOnMock invocationOnMock) -> {
//            final ItemRevision revision = (invocationOnMock.getArgumentAt(0, ItemRevision.class));
//            revision.getItem().setKey(5);
//            return null;
//        }).when(itemRevisionService).save(any());
//
//        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(2, ItemRevision.class))
//                .when(businessRuleRunner).applyRules(eq(null), any(Item.class), any(ItemRevision.class));
//
//        itemIngestService.syncItem(itemBankId);
//
//        verify(itemBankClient).getItemHistory(itemBankId, null);
//        verify(projectLockService).lockProject(itemBankId);
//        ArgumentCaptor<ItemRevision> itemRevisionCaptor = ArgumentCaptor.forClass(ItemRevision.class);
//        verify(itemRevisionService).save(itemRevisionCaptor.capture());
//        ItemRevision revision = itemRevisionCaptor.getValue();
//        assertThat(revision).isNotNull();
//        ItemGitInformation itemGit = revision.getItemGitInformation();
//        assertThat(itemGit).isNotNull();
//        BaseItem imrtItem = revision.getItem();
//        assertThat(imrtItem).isNotNull();
//        Item item = imrtItem.getItemJson();
//        assertThat(item).isNotNull();
//        assertThat(imrtItem.getKey()).isEqualTo(5);
//        verify(projectLockService).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotSyncWhenItembankDoesNotContainItem() {
//        ItemGitInformation existing = new TestItemGitBuilder().build();
//
//        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
//        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.empty());
//
//        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList());
//
//        assertThat(itemIngestService.syncItem(itemBankId)).isNotPresent();
//
//        verify(itemBankClient, times(0)).getItemHistory(itemBankId, existing);
//        verify(projectLockService).lockProject(itemBankId);
//        verify(projectLockService).unlockProject(itemBankId, lockId);
    }

}
