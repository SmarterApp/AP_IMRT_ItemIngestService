package org.opentestsystem.ap.imrt.iis.service.impl;

import org.assertj.core.util.Lists;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.StimItem;
import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.model.ItemLog;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.ImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemBankItemRevisionBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemGitBuilder;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.opentestsystem.ap.imrt.iis.service.ItemConverter;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionProcessor;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionService;
import org.opentestsystem.ap.imrt.iis.service.ProjectLockService;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.isNull;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemIngestServiceImplTest {
    private static final int itemBankId = 432;
    private static final long lockId = 98765;

    @Mock
    private ItemBankClient itemBankClient;

    @Mock
    private ProjectLockService projectLockService;

    @Mock
    private ItemRevisionService itemRevisionService;

    @Mock
    private ItemGitInformationRepository itemGitInformationRepository;

    @Mock
    private OperationalEventService operationalEventService;

    @Mock
    private ItemRevisionProcessor businessRuleRunner;

    @Mock
    private ItemConverter itemConverter;

    private ItemRevision itemRevision;

    private ItemIngestServiceImpl itemIngestService;

    @Before
    public void setup() {
        ItemGitInformation itemGitInformation = new ItemGitInformation();
        itemGitInformation.setProjectId(1);
        BaseItem baseItem = new ImrtItemBuilder()
                .withId(123)
                .withKey(1)
                .build();

        itemRevision = ItemRevision.builder()
                .withBaseItem(baseItem)
                .withItemGitInformation(itemGitInformation)
                .withItemLog(new ItemLog())
                .build();

        itemIngestService = new ItemIngestServiceImpl(projectLockService, itemBankClient,
                itemRevisionService, itemGitInformationRepository, operationalEventService, businessRuleRunner, itemConverter);
    }

    @Test
    public void shouldThrowNoLock() {
        when(projectLockService.lockProject(itemBankId)).thenThrow(new RuntimeException());
        try {
            itemIngestService.syncItem(itemBankId);
            fail();
        } catch (RuntimeException e) {
            verifyZeroInteractions(itemBankClient);
            verify(projectLockService).lockProject(itemBankId);
            verify(projectLockService, never()).unlockProject(anyInt(), anyLong());
        }
    }

    @Test
    public void shouldErrorHistoryThrows() {
        RuntimeException ex = new RuntimeException();
        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder().build();

        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(revision));
        when(itemBankClient.getItemHistory(anyInt(), any(ItemGitInformation.class))).thenThrow(ex);

        try {
            itemIngestService.syncItem(itemBankId);
            fail();
        } catch (Throwable e) {
            verify(itemBankClient).getItemHistory(itemBankId, null);
            verify(projectLockService).lockProject(itemBankId);
            verify(projectLockService).unlockProject(itemBankId, lockId);
        }
    }

    @Test
    public void shouldUseExisting() {
        ItemGitInformation existing = new TestItemGitBuilder().build();
        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder().withRevisionId(existing.getCurrentCommitHash()).build();

        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(revision));
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(existing);
        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList());

        itemIngestService.syncItem(itemBankId);

        verify(itemBankClient).getItemHistory(itemBankId, existing);
        verify(projectLockService).lockProject(itemBankId);
        verify(projectLockService, times(1)).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldRemoveFirstCommit() {
        // Make them match so it will be removed
        ItemGitInformation existing = new TestItemGitBuilder().build();
        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder().withRevisionId(existing.getCurrentCommitHash()).build();

        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(revision));
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(existing);
        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList(revision));

        itemIngestService.syncItem(itemBankId);

        verify(itemBankClient, times(1)).getItemHistory(itemBankId, existing);
        verify(projectLockService, times(1)).lockProject(itemBankId);
        verify(projectLockService, times(1)).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitIdsDontMatch() {
        ImrtItem imrtItem = new ImrtItemBuilder().withKey(3).build();
        ItemGitInformation existing = new TestItemGitBuilder().withImrtItem(imrtItem).build();

        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder()
                .withRevisionId("hash1")
                .withItem(new StimItem("test stim"))
                .build();

        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(revision));
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(existing);
        when(itemConverter.convert(isA(ItemBankItemRevision.class), isA(ItemGitInformation.class))).thenReturn(itemRevision);
        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList(revision));
        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(1, ItemRevision.class))
                .when(businessRuleRunner)
                .applyRules(eq(existing), any(ItemRevision.class));

        itemIngestService.syncItem(itemBankId);

        verify(itemBankClient).getItemHistory(itemBankId, existing);
        verify(projectLockService).lockProject(itemBankId);
        verify(projectLockService, times(1)).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitNoExisting() {
        ItemBankItemRevision itemBankItemRevision = new TestItemBankItemRevisionBuilder()
                .withRevisionId("hash1")
                .withItem(new StimItem("test stim"))
                .build();

        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.of(itemBankItemRevision));
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemGitInformationRepository.findOne(itemBankId)).thenReturn(null);
        when(itemBankClient.getItemHistory(itemBankId, null)).thenReturn(Lists.newArrayList(itemBankItemRevision));
        when(itemConverter.convert(isA(ItemBankItemRevision.class), isNull(ItemGitInformation.class))).thenReturn(itemRevision);

        // When a new item is created in the DB, the key is set at that point. If we don't do this we have a NPE later
        // when the code tries to access the key
        doAnswer((InvocationOnMock invocationOnMock) -> {
            final ItemRevision revision = (invocationOnMock.getArgumentAt(0, ItemRevision.class));
            revision.getItem().setKey(5);
            return null;
        }).when(itemRevisionService).save(any());

        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(1, ItemRevision.class))
                .when(businessRuleRunner).applyRules(eq(null), any(ItemRevision.class));

        itemIngestService.syncItem(itemBankId);

        verify(itemBankClient, times(1)).getItemHistory(itemBankId, null);
        verify(projectLockService, times(1)).lockProject(itemBankId);
        ArgumentCaptor<ItemRevision> itemRevisionCaptor = ArgumentCaptor.forClass(ItemRevision.class);
        verify(itemRevisionService, times(1)).save(itemRevisionCaptor.capture());
        ItemRevision revision = itemRevisionCaptor.getValue();
        assertThat(revision).isNotNull();
        ItemGitInformation itemGit = revision.getItemGitInformation();
        assertThat(itemGit).isNotNull();
        BaseItem imrtItem = revision.getItem();
        assertThat(imrtItem).isNotNull();
        Item item = imrtItem.getItemJson();
        assertThat(item).isNotNull();
        assertThat(imrtItem.getKey()).isEqualTo(5);
        verify(projectLockService, times(1)).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotSyncWhenItembankDoesNotContainItem() {
        ItemGitInformation existing = new TestItemGitBuilder().build();

        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.empty());

        when(itemBankClient.getItemHistory(itemBankId, existing)).thenReturn(Lists.newArrayList());

        assertThat(itemIngestService.syncItem(itemBankId)).isNotPresent();

        verify(itemBankClient, times(0)).getItemHistory(itemBankId, existing);
        verify(projectLockService).lockProject(itemBankId);
        verify(projectLockService).unlockProject(itemBankId, lockId);
    }

    @Test
    public void shouldNotMigrateItemIfItembankDoesNotContainItem() {
        when(projectLockService.lockProject(itemBankId)).thenReturn(lockId);
        when(itemBankClient.findLatestItemBankItemRevision(itemBankId)).thenReturn(Optional.empty());

        assertThat(itemIngestService.syncItem(itemBankId)).isNotPresent();

        verify(projectLockService).lockProject(itemBankId);
        verify(projectLockService).unlockProject(itemBankId, lockId);
        verifyZeroInteractions(itemRevisionService);
        verify(itemBankClient, times(0)).getItemBankItemRevision(isA(ItemGitInformation.class));
    }
}
