package org.opentestsystem.ap.imrt.iis.repository;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.ap.imrt.iis.BaseIntegrationTest;
import org.opentestsystem.ap.imrt.iis.model.ImrtItem;
import org.opentestsystem.ap.imrt.iis.model.ItemGit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;

import static org.assertj.core.api.Assertions.assertThat;

public class ItemGitRepositoryTest extends BaseIntegrationTest {
    private static final Logger logger = LoggerFactory.getLogger(ItemGitRepositoryTest.class);

    @Autowired
    ItemGitRepository itemGitRepository;

    @Autowired
    ImrtItemRepository imrtItemRepository;

    private ImrtItem imrtItem = null;

    @Before
    public void createItem() {
        // create an item in the DB, for our foreign key constraint
        imrtItem = generateItem();
        imrtItem = imrtItemRepository.save(imrtItem);
    }

    @Test
    public void shouldCreateItemGit() {
        // Create the itemGit
        ItemGit itemGit = generateItemGit(9, imrtItem);
        itemGit = itemGitRepository.save(itemGit);
        // If we do a read, we should get back a new object with the same fields
        assertThat(itemGit).isEqualToComparingFieldByFieldRecursively(itemGitRepository.findOne(9));
    }

    @Test
    public void shouldUpdateItemGit() {
        // Create the itemGit
        ItemGit itemGit = generateItemGit(13, imrtItem);
        itemGit = itemGitRepository.save(itemGit);
        ItemGit updated = itemGitRepository.findOne(13);
        updated.setCurrentCommitHash("new commit hash");
        itemGitRepository.save(updated);
        // There should still be only one item in the DB after the update
        assertThat(itemGitRepository.findAll().size()).isEqualTo(1);
        // If we do a read, we should get back a new object with the updated fields
        // Updated at will be later
        ItemGit readItemGit = itemGitRepository.findOne(13);
        assertThat(updated.getUpdatedAt()).isBefore(readItemGit.getUpdatedAt());
        assertThat(updated.getCurrentCommitHash()).isEqualTo(readItemGit.getCurrentCommitHash());
        assertThat(itemGit.getProjectPath()).isEqualTo(readItemGit.getProjectPath());
    }

    @Test
    public void shouldDeleteItemGit() {
        ItemGit itemGit = generateItemGit(11, imrtItem);
        // Save to the DB
        itemGitRepository.save(itemGit);
        // There should be one item_git in the DB after the save
        assertThat(itemGitRepository.findAll().size()).isEqualTo(1);
        itemGitRepository.delete(11);
        // There should be no item_git in the DB after the delete
        assertThat(itemGitRepository.findAll().size()).isEqualTo(0);
    }

    /**
     * Generate a fully populated ItemGit to use in testing
     * @param projectId  Unique projectId
     * @param imrtItem  ImrtItem object as foreign key
     * @return  A fully populated ItemGit object
     */
    private ItemGit generateItemGit(Integer projectId, ImrtItem imrtItem) {
        ItemGit itemGit = new ItemGit();

        itemGit.setItem(imrtItem);
        itemGit.setProjectId(projectId);
        itemGit.setProjectPath("project path");
        itemGit.setCurrentCommitHash("commit hash");
        itemGit.setUpdatedBy("you");

        return itemGit;
    }
}
