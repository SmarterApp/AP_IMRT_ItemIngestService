package org.opentestsystem.ap.imrt.iis.service;

import org.gitlab4j.api.Pager;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.ProjectHook;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.repository.ImrtItemRepository;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.GitLabProjectHookTestBuilder;
import org.opentestsystem.ap.imrt.iis.builder.GitLabProjectTestBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemBankItemRevisionBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemGitBuilder;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.client.ItemEventListener;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.slf4j.Logger;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collections;
import java.util.Optional;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.isNull;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemSynchronizationServiceTest {
    @Mock
    private Logger mockLogger;

    @Mock
    private Pager<Project> mockProjectPager;

    @Mock
    private ItemBankProperties mockItemBankProperties;

    @Mock
    private ItemBankClient mockItemBankClient;

    @Mock
    private OperationalEventService mockOperationalEventService;

    @Mock
    private ImrtItemRepository mockImrtItemRepository;

    @Mock
    private ItemGitInformationRepository mockItemGitInformationRepository;

    @Mock
    private ItemEventListener mockItemEventListener;

    private ItemSynchronizationService itemSynchronizationService;

    @Before
    public void setup() {
        itemSynchronizationService = new ItemSynchronizationServiceImpl(mockItemBankClient,
            mockOperationalEventService,
            mockImrtItemRepository,
            mockItemGitInformationRepository,
            mockItemEventListener);
    }

    @Test
    public void shouldUpdateImrtDatabaseWithMissingItemDataWithoutAnyMissingItemRevisionWarnings() {
        when(mockItemBankProperties.getWebhookUrl())
            .thenReturn("http//webhook/url");

        final Project mockProject = new GitLabProjectTestBuilder().build();
        final ProjectHook mockProjectHook = new GitLabProjectHookTestBuilder()
            .withUrl(mockItemBankProperties.getWebhookUrl())
            .build();

        when(mockItemBankClient.getProjects(100))
            .thenReturn(mockProjectPager);
        when(mockItemBankClient.getItemBankProperties())
            .thenReturn(mockItemBankProperties);
        when(mockItemBankClient.getProjectHooks(mockProject.getId()))
            .thenReturn(Collections.singletonList(mockProjectHook));

        when(mockProjectPager.hasNext())
            .thenAnswer(hasNextAnswer());
        when(mockProjectPager.next())
            .thenReturn(Collections.singletonList(mockProject));
        when(mockImrtItemRepository.findOne(mockProject.getId()))
            .thenReturn(null);

        doNothing().when(mockItemEventListener).onCreateItem(mockProject.getId());
        doNothing().when(mockItemEventListener).onUpdateItem(mockProject.getId());

        itemSynchronizationService.synchronize(Instant.now());

        verify(mockItemBankClient).getProjects(100);
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());

        // hasNext() is called twice; the first time is true because there is a "page" of Projects to process.  The
        // second call determines there are no more Projects to process, so exit the loop.
        verify(mockProjectPager, times(2)).hasNext();
        verify(mockProjectPager).next();
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());
        verify(mockImrtItemRepository).findOne(mockProject.getId());
        verify(mockItemEventListener, never()).onCreateItem(mockProject.getId()); // webhooks match, so no need to create one
        verify(mockItemEventListener).onUpdateItem(mockProject.getId()); // item missing from imrt db, so call update

        verifyZeroInteractions(mockOperationalEventService);
        verifyZeroInteractions(mockItemGitInformationRepository);
        verify(mockItemBankClient, never()).getMostRecentRevision(mockProject.getId());
    }

    @Test
    public void shouldUpdateImrtDatabaseBecauseRevisionHistoryIsMissingWithoutAnyMissingItemRevisionWarnings() {
        when(mockItemBankProperties.getWebhookUrl())
            .thenReturn("http//webhook/url");

        final Project mockProject = new GitLabProjectTestBuilder().build();
        final ProjectHook mockProjectHook = new GitLabProjectHookTestBuilder()
            .withUrl(mockItemBankProperties.getWebhookUrl())
            .build();
        final ImrtItem mockImrtItem = new TestImrtItemBuilder()
            .withKey(mockProject.getId())
            .build();
        final ItemGitInformation mockItemGitInfo = new TestItemGitBuilder()
            .withProjectId(mockProject.getId())
            .withCurrentCommitDate(Instant.now().minus(7, ChronoUnit.DAYS))
            .withCurrentCommitHash("this old hash")
            .build();
        final ItemBankItemRevision mockItemBankItemRevision = new TestItemBankItemRevisionBuilder()
            .withItemBankId(mockProject.getId())
            .build();

        when(mockItemBankClient.getProjects(100))
            .thenReturn(mockProjectPager);
        when(mockItemBankClient.getItemBankProperties())
            .thenReturn(mockItemBankProperties);
        when(mockItemBankClient.getProjectHooks(mockProject.getId()))
            .thenReturn(Collections.singletonList(mockProjectHook));
        when(mockImrtItemRepository.findOne(mockProject.getId()))
            .thenReturn(mockImrtItem);

        when(mockProjectPager.hasNext())
            .thenAnswer(hasNextAnswer());
        when(mockProjectPager.next())
            .thenReturn(Collections.singletonList(mockProject));
        when(mockItemGitInformationRepository.findOne(mockProject.getId()))
            .thenReturn(mockItemGitInfo);
        when(mockItemBankClient.getMostRecentRevision(mockProject.getId()))
            .thenReturn(Optional.of(mockItemBankItemRevision));

        itemSynchronizationService.synchronize(Instant.now());

        verify(mockItemBankClient).getProjects(100);
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());

        // hasNext() is called twice; the first time is true because there is a "page" of Projects to process.  The
        // second call determines there are no more Projects to process, so exit the loop.
        verify(mockProjectPager, times(2)).hasNext();
        verify(mockProjectPager).next();
        verify(mockImrtItemRepository).findOne(mockProject.getId());
        verify(mockItemEventListener).onUpdateItem(mockProject.getId());
        verify(mockItemGitInformationRepository).findOne(mockProject.getId());
        verify(mockItemBankClient).getMostRecentRevision(mockProject.getId());

        verify(mockItemEventListener, never()).onCreateItem(mockProject.getId());
        verifyZeroInteractions(mockOperationalEventService);
    }

    @Test
    public void shouldCreateNewProjectHookForProjectThatDoesNotHaveAnyWebhooks() {
        final Project mockProject = new GitLabProjectTestBuilder().build();

        when(mockItemBankClient.getProjects(100))
            .thenReturn(mockProjectPager);
        when(mockItemBankClient.getProjectHooks(mockProject.getId()))
            .thenReturn(Collections.emptyList());
        when(mockImrtItemRepository.findOne(mockProject.getId()))
            .thenReturn(null);

        when(mockProjectPager.hasNext())
            .thenAnswer(hasNextAnswer());
        when(mockProjectPager.next())
            .thenReturn(Collections.singletonList(mockProject));

        itemSynchronizationService.synchronize(Instant.now());

        verify(mockItemBankClient).getProjects(100);

        // hasNext() is called twice; the first time is true because there is a "page" of Projects to process.  The
        // second call determines there are no more Projects to process, so exit the loop.
        verify(mockProjectPager, times(2)).hasNext();
        verify(mockProjectPager).next();
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());
        verify(mockItemEventListener).onCreateItem(mockProject.getId());
        verify(mockImrtItemRepository).findOne(mockProject.getId());
        verify(mockItemEventListener).onUpdateItem(mockProject.getId());

        verifyZeroInteractions(mockItemGitInformationRepository);
        verify(mockItemBankClient, never()).getMostRecentRevision(mockProject.getId());
        verifyZeroInteractions(mockOperationalEventService);
    }

    @Test
    public void shouldCreateNewProjectHookForProjectThatHasADifferentWebhook() {
        when(mockItemBankProperties.getWebhookUrl())
            .thenReturn("http//webhook/url");

        final Project mockProject = new GitLabProjectTestBuilder().build();
        final ProjectHook mockProjectHook = new GitLabProjectHookTestBuilder()
            .withUrl("http://some/other/webhook/url")
            .build();

        when(mockItemBankClient.getProjects(100))
            .thenReturn(mockProjectPager);
        when(mockItemBankClient.getItemBankProperties())
            .thenReturn(mockItemBankProperties);
        when(mockItemBankClient.getProjectHooks(mockProject.getId()))
            .thenReturn(Collections.singletonList(mockProjectHook));
        when(mockItemBankClient.getProjectHooks(mockProject.getId()))
            .thenReturn(Collections.singletonList(mockProjectHook));
        when(mockImrtItemRepository.findOne(mockProject.getId()))
            .thenReturn(null);

        when(mockProjectPager.hasNext())
            .thenAnswer(hasNextAnswer());
        when(mockProjectPager.next())
            .thenReturn(Collections.singletonList(mockProject));

        itemSynchronizationService.synchronize(Instant.now());

        verify(mockItemBankClient).getProjects(100);
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());

        // hasNext() is called twice; the first time is true because there is a "page" of Projects to process.  The
        // second call determines there are no more Projects to process, so exit the loop.
        verify(mockProjectPager, times(2)).hasNext();
        verify(mockProjectPager).next();
        verify(mockItemBankClient).getProjectHooks(mockProject.getId());
        verify(mockItemEventListener).onCreateItem(mockProject.getId());
        verify(mockImrtItemRepository).findOne(mockProject.getId());
        verify(mockItemEventListener).onUpdateItem(mockProject.getId());

        verifyZeroInteractions(mockItemGitInformationRepository);
        verify(mockItemBankClient, never()).getMostRecentRevision(mockProject.getId());
        verifyZeroInteractions(mockOperationalEventService);
    }

    @Test
    public void shouldExecuteWithAMissingItemRevisionWarning() {
        final Project mockProject = new GitLabProjectTestBuilder().build();
        final ImrtItem mockImrtItem = new TestImrtItemBuilder()
            .withKey(mockProject.getId())
            .build();
        final ItemGitInformation mockItemGitInfo = new TestItemGitBuilder()
            .withProjectId(mockProject.getId())
            .withCurrentCommitDate(Instant.now().minus(7, ChronoUnit.DAYS))
            .withCurrentCommitHash("this old hash")
            .build();

        when(mockItemBankClient.getProjects(100))
            .thenReturn(mockProjectPager);
        when(mockImrtItemRepository.findOne(mockProject.getId()))
            .thenReturn(mockImrtItem);


        when(mockProjectPager.hasNext())
            .thenAnswer(hasNextAnswer());
        when(mockProjectPager.next())
            .thenReturn(Collections.singletonList(mockProject));
        when(mockItemGitInformationRepository.findOne(mockProject.getId()))
            .thenReturn(mockItemGitInfo);
        when(mockItemBankClient.getMostRecentRevision(mockProject.getId()))
            .thenReturn(Optional.empty());

        doNothing().when(mockOperationalEventService).serviceWarning(mockLogger,
            null,
            "Could not find any revisions on master branch for item id '{}'",
            mockProject.getId());
        doNothing().when(mockItemEventListener).onUpdateItem(mockProject.getId());

        itemSynchronizationService.synchronize(Instant.now());

        verify(mockItemBankClient).getProjects(100);

        // hasNext() is called twice; the first time is true because there is a "page" of Projects to process.  The
        // second call determines there are no more Projects to process, so exit the loop.
        verify(mockProjectPager, times(2)).hasNext();
        verify(mockProjectPager).next();
        verify(mockImrtItemRepository).findOne(mockProject.getId());
        verify(mockItemGitInformationRepository).findOne(mockProject.getId());
        verify(mockItemBankClient).getMostRecentRevision(mockProject.getId());
        verify(mockOperationalEventService).serviceWarning(mockLogger,
            null,
            "Could not find any revisions on master branch for item id '{}'",
            mockProject.getName());

        verifyZeroInteractions(mockItemEventListener);
    }

    /**
     * The first time we call hasNext(), return true.  Otherwise, return false (to simulate having no more records in
     * the mockProjectPager).
     *
     * @return An {@link org.mockito.stubbing.Answer} that represents hasNext() being called multiple times.
     */
    private Answer hasNextAnswer() {
        return new Answer() {
            private int callCounter = 0;

            @Override
            public Object answer(final InvocationOnMock invocation) {
                return ++callCounter == 1;
            }
        };
    }
}
