package org.opentestsystem.ap.imrt.iis.service;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.model.Stimulus;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.ImrtItemBuilder;
import org.slf4j.Logger;

import java.util.Optional;

import static org.mockito.Matchers.any;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemDeleteNotificationHandlerTest {
    @Mock
    private OperationalEventService mockOperationalEventService;

    @Mock
    private ProjectLockService mockProjectLockService;

    @Mock
    private BaseItemService mockBaseItemService;

    private ItemDeleteNotificationHandler itemDeleteNotificationHandler;

    private BaseItem baseItem;

    @Before
    public void setUp() {
        itemDeleteNotificationHandler = new ItemDeleteNotificationHandler(mockOperationalEventService,
                mockProjectLockService,
                mockBaseItemService);

        baseItem = new ImrtItemBuilder()
                .withKey(1)
                .build();
    }

    @Test
    public void shouldDeleteAnItem() {
        when(mockBaseItemService.findBaseItemByItemId(baseItem.getId()))
                .thenReturn(Optional.of(baseItem));

        itemDeleteNotificationHandler.processItemMessage(baseItem.getId());

        verify(mockProjectLockService).lockProject(baseItem.getId());
        ;

        verify(mockBaseItemService).deleteItem(baseItem);
        verify(mockOperationalEventService).itemDeletedEvent(any(Logger.class),
                eq(baseItem.getKey()),
                eq(baseItem.getId()));
        verify(mockProjectLockService).unlockProject(isA(Integer.class), isA(Long.class));
    }

    @Test
    public void shouldDeleteAStimulus() {
        final Stimulus stimulus = new Stimulus();
        stimulus.setKey(13);
        stimulus.setId(123);

        when(mockBaseItemService.findBaseItemByItemId(stimulus.getId())).thenReturn(Optional.of(stimulus));

        itemDeleteNotificationHandler.processItemMessage(stimulus.getId());

        verify(mockProjectLockService).lockProject(stimulus.getId());

        // We're deleting an stimulus, so the Item-specific delete methods should not be hit.
        verify(mockBaseItemService).deleteItem(stimulus);
        verify(mockOperationalEventService).itemDeletedEvent(any(Logger.class),
                eq(stimulus.getKey()),
                eq(stimulus.getId()));
        verify(mockProjectLockService).unlockProject(isA(Integer.class), isA(Long.class));
    }

    @Test
    public void shouldNotTryToDeleteWhenItemGitInformationCannotBeFound() {
        when(mockBaseItemService.findBaseItemByItemId(1))
                .thenReturn(Optional.empty());

        itemDeleteNotificationHandler.processItemMessage(1);

        verify(mockBaseItemService, times(0)).deleteItem(isA(BaseItem.class));
    }
}
