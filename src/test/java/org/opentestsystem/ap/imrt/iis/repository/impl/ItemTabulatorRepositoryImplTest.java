package org.opentestsystem.ap.imrt.iis.repository.impl;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.model.validation.ValidationResults;
import org.opentestsystem.ap.imrt.iis.config.ItemIngestServiceProperties;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemTabulatorRepositoryImplTest {
    @Mock
    private RestTemplateBuilder mockRestTemplateBuilder;

    @Mock
    private RestTemplate mockRestTemplate;

    @Mock
    private OperationalEventService mockOperationalEventService;

    private String validationUrl = "http://localhost:8080";

    private ItemTabulatorRepositoryImpl itemTabulatorRepository;

    @Before
    public void setUp() {
        ItemIngestServiceProperties itemIngestServiceProperties = new ItemIngestServiceProperties();
        itemIngestServiceProperties.setItemValidationServiceUrl(validationUrl);

        when(mockRestTemplateBuilder.build()).thenReturn(mockRestTemplate);

        itemTabulatorRepository = new ItemTabulatorRepositoryImpl(mockOperationalEventService, mockRestTemplateBuilder, itemIngestServiceProperties);
    }

    @Test
    public void shouldGetValidationResults() {
        URI uri = UriComponentsBuilder.fromUriString(validationUrl)
                .path("api/v1/validate/1")
                .build()
                .toUri();

        ValidationResults results = new ValidationResults();

        ResponseEntity<ValidationResults> validationResultsResponseEntity = new ResponseEntity<>(results, HttpStatus.OK);

        when(mockRestTemplate.getForEntity(uri, ValidationResults.class)).thenReturn(validationResultsResponseEntity);

        Optional<ValidationResults> maybeResults = itemTabulatorRepository.getValidationResults(1);

        verifyZeroInteractions(mockOperationalEventService);

        assertThat(maybeResults).isPresent();
        assertThat(maybeResults.get()).isEqualTo(results);
    }

    @Test
    public void shouldReturnEmptyIfIvsReturns404() {
        URI uri = UriComponentsBuilder.fromUriString(validationUrl)
                .path("api/v1/validate/1")
                .build()
                .toUri();

        when(mockRestTemplate.getForEntity(uri, ValidationResults.class)).thenThrow(new HttpClientErrorException(HttpStatus.NOT_FOUND));

        Optional<ValidationResults> maybeResults = itemTabulatorRepository.getValidationResults(1);

        assertThat(maybeResults).isNotPresent();
    }

    @Test(expected = HttpClientErrorException.class)
    public void shouldRethrowIfUnexpectedClientError() {
        URI uri = UriComponentsBuilder.fromUriString(validationUrl)
                .path("api/v1/validate/1")
                .build()
                .toUri();

        when(mockRestTemplate.getForEntity(uri, ValidationResults.class)).thenThrow(new HttpClientErrorException(HttpStatus.INTERNAL_SERVER_ERROR));

        itemTabulatorRepository.getValidationResults(1);
    }
}