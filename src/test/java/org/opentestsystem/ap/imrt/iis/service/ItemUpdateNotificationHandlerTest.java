package org.opentestsystem.ap.imrt.iis.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.assertj.core.util.Lists;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.RepositoryFile;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.TestCommitBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemGitBuilder;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevisionImpl;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Base64;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class ItemUpdateNotificationHandlerTest {

    private static final int itemId = 432;
    private static final long lockId = 98765;
    private static final ItemParser itemParser = new ItemParser(new ObjectMapper());

    @Mock
    private ItemBankClient itemBankClient;

    @Mock
    private ProjectLockService projectLockService;

    @Mock
    private ItemRevisionWriter itemRevisionWriter;

    @Mock
    private ItemGitInformationRepository itemGitInformationRepository;

    @Mock
    private OperationalEventService operationalEventService;

    // class under test
    private ItemUpdateNotificationHandler itemUpdateNotificationHandler;

    @Before
    public void setup() {
        itemUpdateNotificationHandler = new ItemUpdateNotificationHandler(projectLockService, itemBankClient, itemParser,
                itemRevisionWriter, itemGitInformationRepository, operationalEventService);
    }

    @Test
    public void shouldThrowNoLock() {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.empty());
        try {
            itemUpdateNotificationHandler.updateItem(itemId);
            fail();
        } catch (RuntimeException e) {
            verifyZeroInteractions(itemBankClient);
            verify(projectLockService, times(1)).lockProject(itemId);
            verify(projectLockService, times(0)).unlockProject(anyInt(), anyLong());
        }
    }

    @Test
    public void shouldErrorHistoryThrows() {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.of(lockId));
        RuntimeException ex = new RuntimeException();
        when(itemBankClient.getItemHistory(anyInt(), any(Instant.class))).thenThrow(ex);

        itemUpdateNotificationHandler.updateItem(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, Instant.ofEpochSecond(0));
        verify(projectLockService, times(1)).lockProject(itemId);
        verify(operationalEventService, times(1)).serviceError(any(), eq(ex),
                any(), eq(itemId));
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldUseExistingSinceDate() {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.of(lockId));
        ItemGitInformation existing = new TestItemGitBuilder().build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList());

        itemUpdateNotificationHandler.updateItem(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService, times(1)).lockProject(itemId);
        verifyZeroInteractions(operationalEventService);
        verify(itemBankClient, times(0)).getFile(anyString(), anyInt(), anyString());
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldRemoveFirstCommit() {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.of(lockId));
        ItemGitInformation existing = new TestItemGitBuilder().build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);
        // Make them match so it will be removed
        Commit commit = new TestCommitBuilder().withId(existing.getCurrentCommitHash()).build();
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList(commit));

        itemUpdateNotificationHandler.updateItem(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService, times(1)).lockProject(itemId);
        verifyZeroInteractions(operationalEventService);
        verify(itemBankClient, times(0)).getFile(anyString(), anyInt(), anyString());
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitIdsDontMatch() throws IOException {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.of(lockId));
        ImrtItem imrtItem = new TestImrtItemBuilder().withKey(3).build();
        ItemGitInformation existing = new TestItemGitBuilder().withImrtItem(imrtItem).build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);
        Commit commit = new TestCommitBuilder().withId("hash1").build();
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList(commit));
        RepositoryFile file = new RepositoryFile();
        file.setContent(getJsonContent("json/good-item.json"));
        when(itemBankClient.getFile("item.json", itemId, "hash1")).thenReturn(file);

        itemUpdateNotificationHandler.updateItem(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService, times(1)).lockProject(itemId);
        verify(operationalEventService, times(1)).itemUpdatedEvent(any(Logger.class), eq(3), anyString(), anyInt());
        verify(operationalEventService, times(0)).serviceError(any(Logger.class), any(Exception.class),
                anyString(), anyInt());
        verify(itemBankClient, times(1)).getFile(anyString(), anyInt(), anyString());
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitNoExisting() throws IOException {
        when(projectLockService.lockProject(itemId)).thenReturn(Optional.of(lockId));
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(null);
        Commit commit = new TestCommitBuilder().withId("hash1").build();
        when(itemBankClient.getItemHistory(itemId, Instant.ofEpochSecond(0))).thenReturn(Lists.newArrayList(commit));
        RepositoryFile file = new RepositoryFile();
        file.setContent(getJsonContent("json/good-item.json"));
        when(itemBankClient.getFile("item.json", itemId, "hash1")).thenReturn(file);

        doAnswer((InvocationOnMock invocationOnMock) -> {
                final ItemRevision revision = (invocationOnMock.getArgumentAt(0, ItemRevision.class));
                revision.getImrtItem().setKey(5);
                return null;
            }).when(itemRevisionWriter).saveItemRevision(any());

        itemUpdateNotificationHandler.updateItem(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, Instant.ofEpochSecond(0));
        verify(projectLockService, times(1)).lockProject(itemId);
        verify(operationalEventService, times(1)).itemCreatedEvent(any(Logger.class), eq(5), anyString(), anyInt());
        verify(operationalEventService, times(0)).serviceError(any(Logger.class), any(Exception.class),
                anyString(), anyInt());
        verify(itemBankClient, times(1)).getFile("item.json", itemId, "hash1");
        ArgumentCaptor<ItemRevisionImpl> itemRevisionCaptor = ArgumentCaptor.forClass(ItemRevisionImpl.class);
        verify(itemRevisionWriter, times(1)).saveItemRevision(itemRevisionCaptor.capture());
        ItemRevisionImpl revision = itemRevisionCaptor.getValue();
        assertThat(revision).isNotNull();
        ItemGitInformation itemGit = revision.getItemGitInformation();
        assertThat(itemGit).isNotNull();
        ImrtItem imrtItem = revision.getImrtItem();
        assertThat(imrtItem).isNotNull();
        Item item = imrtItem.getItemJson();
        assertThat(item).isNotNull();
        assertThat(imrtItem.getKey()).isEqualTo(5);
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    /**
     * Retrieve the json from a file and return it as a base64 encoded string
     *
     * @param filePath The path of the file, relative to src/test/resources
     * @return The base64 encoded version of the file's contents
     * @throws IOException If something goes wrong
     */
    private String getJsonContent(String filePath) throws IOException {
        URL url = getClass().getClassLoader().getResource(filePath);
        return (new String(Base64.getEncoder().encode(Files.readAllBytes(Paths.get(url.getPath()))), "UTF-8"));
    }

}
