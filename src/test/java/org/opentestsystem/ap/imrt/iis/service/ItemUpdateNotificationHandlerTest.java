package org.opentestsystem.ap.imrt.iis.service;

import org.assertj.core.util.Lists;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.StimItem;
import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.TestImrtItemBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemBankItemRevisionBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestItemGitBuilder;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevisionImpl;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.slf4j.Logger;

import java.time.Instant;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyLong;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@Ignore
@RunWith(MockitoJUnitRunner.class)
public class ItemUpdateNotificationHandlerTest {

    private static final int itemId = 432;
    private static final long lockId = 98765;

    @Mock
    private ItemBankClient itemBankClient;

    @Mock
    private ProjectLockService projectLockService;

    @Mock
    private ItemRevisionWriter itemRevisionWriter;

    @Mock
    private ItemGitInformationRepository itemGitInformationRepository;

    @Mock
    private OperationalEventService operationalEventService;

    @Mock
    private ItemRevisionProcessor businessRuleRunner;

    // class under test
    private ItemUpdateNotificationHandler itemUpdateNotificationHandler;

    @Before
    public void setup() {
        itemUpdateNotificationHandler = new ItemUpdateNotificationHandler(projectLockService, itemBankClient,
                itemRevisionWriter, itemGitInformationRepository, operationalEventService, businessRuleRunner);
    }

    @Test
    public void shouldThrowNoLock() {
        when(projectLockService.lockProject(itemId)).thenThrow(new RuntimeException());
        try {
            itemUpdateNotificationHandler.processItemMessage(itemId);
            fail();
        } catch (RuntimeException e) {
            verifyZeroInteractions(itemBankClient);
            verify(projectLockService).lockProject(itemId);
            verify(projectLockService, never()).unlockProject(anyInt(), anyLong());
        }
    }

    @Test
    public void shouldErrorHistoryThrows() {
        when(projectLockService.lockProject(itemId)).thenReturn(lockId);
        RuntimeException ex = new RuntimeException();
        when(itemBankClient.getItemHistory(anyInt(), any(Instant.class))).thenThrow(ex);

        try {
            itemUpdateNotificationHandler.processItemMessage(itemId);
            fail();
        } catch (Throwable e) {
            verify(itemBankClient).getItemHistory(itemId, Instant.ofEpochSecond(0));
            verify(projectLockService).lockProject(itemId);
            verify(projectLockService).unlockProject(itemId, lockId);
        }
    }

    @Test
    public void shouldUseExistingSinceDate() {
        when(projectLockService.lockProject(itemId)).thenReturn(lockId);
        ItemGitInformation existing = new TestItemGitBuilder().build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList());

        itemUpdateNotificationHandler.processItemMessage(itemId);

        verify(itemBankClient).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService).lockProject(itemId);
        verifyZeroInteractions(operationalEventService);
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldRemoveFirstCommit() {
        when(projectLockService.lockProject(itemId)).thenReturn(lockId);
        ItemGitInformation existing = new TestItemGitBuilder().build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);
        // Make them match so it will be removed
        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder().withRevisionId(existing.getCurrentCommitHash()).build();
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList(revision));

        itemUpdateNotificationHandler.processItemMessage(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService, times(1)).lockProject(itemId);
        verifyZeroInteractions(operationalEventService);
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitIdsDontMatch() {
        when(projectLockService.lockProject(itemId)).thenReturn(lockId);
        ImrtItem imrtItem = new TestImrtItemBuilder().withKey(3).build();
        ItemGitInformation existing = new TestItemGitBuilder().withImrtItem(imrtItem).build();
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(existing);

        ItemBankItemRevision revision = new TestItemBankItemRevisionBuilder()
                .withRevisionId("hash1").withItem(new StimItem("test stim")).build();
        when(itemBankClient.getItemHistory(itemId, existing.getCurrentCommitDate())).thenReturn(Lists.newArrayList(revision));
        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(1, ItemRevision.class))
                .when(businessRuleRunner).applyRules(eq(existing), any(ItemRevision.class));

        itemUpdateNotificationHandler.processItemMessage(itemId);

        verify(itemBankClient).getItemHistory(itemId, existing.getCurrentCommitDate());
        verify(projectLockService).lockProject(itemId);
        verify(operationalEventService).itemUpdatedEvent(any(Logger.class), eq(3), anyString(), anyInt());
        verify(operationalEventService, never()).serviceError(any(Logger.class), any(Exception.class),
                anyString(), anyInt());
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }

    @Test
    public void shouldNotRemoveFirstCommitNoExisting() {
        when(projectLockService.lockProject(itemId)).thenReturn(lockId);
        when(itemGitInformationRepository.findOne(itemId)).thenReturn(null);
        ItemBankItemRevision itemBankItemRevision = new TestItemBankItemRevisionBuilder()
                .withRevisionId("hash1").withItem(new StimItem("test stim")).build();
        when(itemBankClient.getItemHistory(itemId, Instant.ofEpochSecond(0))).thenReturn(Lists.newArrayList(itemBankItemRevision));

        // When a new item is created in the DB, the key is set at that point. If we don't do this we have a NPE later
        // when the code tries to access the key
        doAnswer((InvocationOnMock invocationOnMock) -> {
            final ItemRevision revision = (invocationOnMock.getArgumentAt(0, ItemRevision.class));
            revision.getItem().setKey(5);
            return null;
        }).when(itemRevisionWriter).saveItemRevision(any());

        doAnswer((InvocationOnMock invocationOnMock) -> invocationOnMock.getArgumentAt(1, ItemRevision.class))
                .when(businessRuleRunner).applyRules(eq(null), any(ItemRevision.class));

        itemUpdateNotificationHandler.processItemMessage(itemId);

        verify(itemBankClient, times(1)).getItemHistory(itemId, Instant.ofEpochSecond(0));
        verify(projectLockService, times(1)).lockProject(itemId);
        verify(operationalEventService, times(1)).itemCreatedEvent(any(Logger.class), eq(5), anyString(), anyInt());
        verify(operationalEventService, times(0)).serviceError(any(Logger.class), any(Exception.class),
                anyString(), anyInt());
        ArgumentCaptor<ItemRevisionImpl> itemRevisionCaptor = ArgumentCaptor.forClass(ItemRevisionImpl.class);
        verify(itemRevisionWriter, times(1)).saveItemRevision(itemRevisionCaptor.capture());
        ItemRevisionImpl revision = itemRevisionCaptor.getValue();
        assertThat(revision).isNotNull();
        ItemGitInformation itemGit = revision.getItemGitInformation();
        assertThat(itemGit).isNotNull();
        BaseItem imrtItem = revision.getItem();
        assertThat(imrtItem).isNotNull();
        Item item = imrtItem.getItemJson();
        assertThat(item).isNotNull();
        assertThat(imrtItem.getKey()).isEqualTo(5);
        verify(projectLockService, times(1)).unlockProject(itemId, lockId);
    }
}
