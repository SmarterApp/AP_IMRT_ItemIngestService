package org.opentestsystem.ap.imrt.iis.service.impl;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.common.imrt.exception.NotFoundException;
import org.opentestsystem.ap.imrt.iis.batch.impl.SpringBatchJobManagementServiceImpl;
import org.opentestsystem.ap.imrt.iis.model.JobExecutionResponse;
import org.opentestsystem.ap.imrt.iis.batch.SpringBatchJobManagementService;
import org.springframework.batch.core.BatchStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobInstance;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobOperator;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class SpringBatchJobManagementServiceImplTest {
    @Mock
    private JobExplorer mockJobExplorer;

    @Mock
    private JobOperator mockJobOperator;

    private SpringBatchJobManagementService springBatchJobManagementService;

    @Before
    public void setup() {
        springBatchJobManagementService = new SpringBatchJobManagementServiceImpl(mockJobExplorer, mockJobOperator);
    }

    @Test
    public void shouldAbandonAJobExecutionInARunningState() throws JobExecutionException {
        final Long jobInstanceId = 42L;
        final Long jobExecutionId = 13L;
        final JobInstance jobInstance = new JobInstance(jobInstanceId, "unit-test-job-instance");

        final JobExecution jobExecution = new JobExecution(jobExecutionId);
        jobExecution.setStatus(BatchStatus.STARTING);

        final JobExecution abandonedJobExecution = new JobExecution(jobExecutionId);
        abandonedJobExecution.setStatus(BatchStatus.ABANDONED);
        abandonedJobExecution.setJobInstance(jobInstance);

        when(mockJobExplorer.getJobInstance(jobInstanceId))
                .thenReturn(jobInstance);
        when(mockJobExplorer.findRunningJobExecutions(jobInstance.getJobName()))
                .thenReturn(Collections.singleton(jobExecution));
        when(mockJobExplorer.getJobExecution(abandonedJobExecution.getId()))
                .thenReturn(abandonedJobExecution);

        final JobExecutionResponse response = springBatchJobManagementService.abandon(jobInstanceId);

        verify(mockJobExplorer).getJobInstance(jobInstance.getId());
        verify(mockJobExplorer).findRunningJobExecutions(jobInstance.getJobName());
        verify(mockJobOperator).stop(jobExecution.getId());
        verify(mockJobOperator).abandon(jobExecution.getId());
        verify(mockJobExplorer).getJobExecution(jobExecution.getId());

        assertThat(response.getJobExecutionId()).isEqualTo(jobExecution.getId());
        assertThat(response.getJobInstanceId()).isEqualTo(jobInstance.getId());
        assertThat(response.getName()).isEqualTo(jobInstance.getJobName());
        assertThat(response.getStatus()).isEqualTo(BatchStatus.ABANDONED.toString());
        assertThat(response.getMessage()).isEqualTo(String.format("Job Execution %d for Job %s abandoned successfully",
                abandonedJobExecution.getId(),
                abandonedJobExecution.getJobInstance().getJobName()));
    }

    @Test
    public void shouldReturnJobExecutionResponseWhenThereAreNoJobExecutionsToAbandon() {
        final Long jobInstanceId = 42L;
        final Long jobExecutionId = 13L;
        final JobInstance jobInstance = new JobInstance(jobInstanceId, "unit-test-job-instance");

        when(mockJobExplorer.getJobInstance(jobInstanceId))
                .thenReturn(jobInstance);
        when(mockJobExplorer.findRunningJobExecutions(jobInstance.getJobName()))
                .thenReturn(Collections.emptySet());

        final JobExecutionResponse response = springBatchJobManagementService.abandon(jobInstanceId);

        verify(mockJobExplorer).getJobInstance(jobInstance.getId());
        verify(mockJobExplorer).findRunningJobExecutions(jobInstance.getJobName());
        verifyZeroInteractions(mockJobOperator);
        verify(mockJobExplorer, never()).getJobExecution(jobExecutionId);

        assertThat(response.getJobExecutionId()).isEqualTo(0L);
        assertThat(response.getJobInstanceId()).isEqualTo(jobInstance.getId());
        assertThat(response.getName()).isEqualTo(jobInstance.getJobName());
        assertThat(response.getStatus()).isEqualTo("NO JOB EXECUTIONS");
        assertThat(response.getMessage()).isEqualTo(String.format("No job executions are currently running for the %s (job instance id %d)",
                jobInstance.getJobName(),
                jobInstance.getId()));
    }

    @Test(expected = IllegalStateException.class)
    public void shouldThrowExceptionWhenThereAreMultipleJobExecutionsRunning() {
        final Long jobInstanceId = 42L;
        final JobInstance jobInstance = new JobInstance(jobInstanceId, "unit-test-job-instance");

        final JobExecution runningJobExecution = new JobExecution(13L);
        runningJobExecution.setStatus(BatchStatus.STARTING);
        runningJobExecution.setJobInstance(jobInstance);

        final JobExecution anotherRunningJobExecution = new JobExecution(14L);
        anotherRunningJobExecution.setStatus(BatchStatus.STARTING);
        anotherRunningJobExecution.setJobInstance(jobInstance);

        when(mockJobExplorer.getJobInstance(jobInstanceId))
                .thenReturn(jobInstance);
        when(mockJobExplorer.findRunningJobExecutions(jobInstance.getJobName()))
                .thenReturn(new HashSet<>(Arrays.asList(runningJobExecution, anotherRunningJobExecution)));

        springBatchJobManagementService.abandon(jobInstanceId);

        verify(mockJobExplorer).getJobInstance(jobInstance.getId());
        verify(mockJobExplorer).findRunningJobExecutions(jobInstance.getJobName());
    }

    @Test(expected = NotFoundException.class)
    public void shouldThrowExceptionWhenJobInstanceCannotBeFound() {
        when(mockJobExplorer.getJobInstance(42L))
                .thenReturn(null);

        springBatchJobManagementService.abandon(13L);
    }
}
