package org.opentestsystem.ap.imrt.iis.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.assertj.core.util.Lists;
import org.gitlab4j.api.CommitsApi;
import org.gitlab4j.api.GitLabApi;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.Pager;
import org.gitlab4j.api.ProjectApi;
import org.gitlab4j.api.RepositoryApi;
import org.gitlab4j.api.RepositoryFileApi;
import org.gitlab4j.api.models.Branch;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.webhook.EventProject;
import org.gitlab4j.api.webhook.PushEvent;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.TestCommitBuilder;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.exception.GitLabApiRuntimeException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;

import javax.ws.rs.core.Response;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Matchers.isNull;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
@SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT") // Required because findbugs is throwing errors on some of the verify statements
public class GitlabClientImplTest {
    private static final String ITEM_FILE_NAME = "item.json";
    private static final String MASTER_BRANCH_NAME = "master";
    private static final String CREATE_BRANCH_NAME = "create_user";
    private static final String ITEM_BANK_PATH = "item bank path";
    private static final int MAX_ITEMS_PER_PAGE = 100;
    private Date existingCommitDate;
    private Date zeroDate = Date.from(Instant.ofEpochSecond(0));

    @Mock
    private GitLabApi gitLabApi;

    @Mock
    private ItemBankProperties itemBankProperties;

    @Mock
    private ItemEventListener itemEventListener;

    @Mock
    private OperationalEventService operationalEventService;

    @Mock
    private ItemGitInformation existingGitInfo;

    @Mock
    private ImrtItem imrtItem;

    @Mock
    private Pager<Commit> emptyCommitPager;

    @Mock
    private CommitsApi commitsApi;

    @Mock
    private RepositoryFileApi fileApi;

    @Mock
    private RepositoryApi repoApi;

    private ObjectMapper objectMapper = new ObjectMapper();

    // Object under test
    private GitlabClientImpl client;

    @Before
    public void setup() {
        when(itemBankProperties.getGroup()).thenReturn(ITEM_BANK_PATH);
        client = new GitlabClientImpl(itemBankProperties, operationalEventService, new ItemParser(objectMapper));
        client.setGitLabApi(gitLabApi);
        when(gitLabApi.getCommitsApi()).thenReturn(commitsApi);
        when(gitLabApi.getRepositoryFileApi()).thenReturn(fileApi);
        when(gitLabApi.getRepositoryApi()).thenReturn(repoApi);
        when(existingGitInfo.getItem()).thenReturn(imrtItem);
        when(existingGitInfo.getCurrentCommitDate()).thenReturn(Instant.now());
        existingCommitDate = Date.from(existingGitInfo.getCurrentCommitDate());
        when(imrtItem.isBeingCreated()).thenReturn(false);
        when(emptyCommitPager.hasNext()).thenReturn(false);
    }

    @Test
    public void shouldReturnEmptyList() throws GitLabApiException {
        when(commitsApi.getCommits(99, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
                .thenReturn(emptyCommitPager);

        List<ItemBankItemRevision> result = client.getItemHistory(99, existingGitInfo);

        assertThat(result).isEmpty();
        verify(commitsApi).getCommits(99, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        verify(emptyCommitPager).hasNext();
        verify(emptyCommitPager, never()).next();
    }

    @Test
    public void historyShouldUseSinceZero() throws GitLabApiException {
        int itemBankId = 77;
        when(commitsApi.getCommits(itemBankId, MASTER_BRANCH_NAME, zeroDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(null);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, null);

        assertThat(result.size()).isEqualTo(0);
        verify(commitsApi).getCommits(itemBankId, MASTER_BRANCH_NAME, zeroDate,
                null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldUseMasterBranchNotBeingCreated() throws GitLabApiException {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(false);
        when(commitsApi.getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(commitsApi).getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate,
                null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldUseMasterBranchItemExists() throws GitLabApiException {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(commitsApi.getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(null);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(commitsApi).getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate,
                null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldThrowCheckingMasterBranchItemExists() throws GitLabApiException {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(commitsApi.getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenThrow(new GitLabApiException("Error"));

        try {
            client.getItemHistory(itemBankId, existingGitInfo);
            fail();
        } catch (GitLabApiRuntimeException re) {
            assertThat(re.getCause().getMessage()).isEqualTo("Error");
            verify(operationalEventService).serviceError(any(Logger.class), eq(re.getCause()), eq("Unable to retrieve history for itemBankId {} since {}"),
                    eq(itemBankId), any(Instant.class));
        }
    }

    @Test
    public void historyShouldThrowFindingCreateBranch() throws GitLabApiException {
        int itemBankId = 77;
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenThrow(new GitLabApiException(Response.status(404).build()));
        when(repoApi.getBranches(itemBankId)).thenReturn(Lists.newArrayList());

        try {
            client.getItemHistory(itemBankId, null);
            fail();
        } catch (GitLabApiRuntimeException re) {
            assertThat(re.getMessage()).isEqualTo("Unable to find create_<user> branch for itemBankId " + itemBankId);
            verify(operationalEventService).serviceError(any(Logger.class), isNull(Throwable.class), eq("Unable to find create_<user> branch for itemBankId {}"),
                    eq(itemBankId));
        }
    }
    @Test
    public void historyShouldUseCreateBranchItemExists() throws GitLabApiException {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(commitsApi.getCommits(itemBankId, CREATE_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenThrow(new GitLabApiException(Response.status(404).build()));
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(commitsApi).getCommits(itemBankId, CREATE_BRANCH_NAME, existingCommitDate,
                null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldUseCreateBranchFindBranch() throws GitLabApiException {
        int itemBankId = 77;
        when(commitsApi.getCommits(itemBankId, CREATE_BRANCH_NAME, zeroDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(emptyCommitPager);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenThrow(new GitLabApiException(Response.status(404).build()));
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);
        Branch b = new Branch();
        b.setName(CREATE_BRANCH_NAME);
        when(repoApi.getBranches(itemBankId)).thenReturn(Lists.newArrayList(b));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, null);

        assertThat(result.size()).isEqualTo(0);
        verify(commitsApi).getCommits(itemBankId, CREATE_BRANCH_NAME, zeroDate,
                null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void shouldGetRevisionsFromMaster() throws GitLabApiException, IOException {
        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList1 = Lists.newArrayList(commit1, commit2);
        List<Commit> commitList2 = Lists.newArrayList(commit3);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList1).thenReturn(commitList2);
        when(commitsApi.getCommits(itemBankId, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(pager);

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(file);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(commitList1.size() + commitList2.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3, MASTER_BRANCH_NAME);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2, MASTER_BRANCH_NAME);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1, MASTER_BRANCH_NAME);
        verify(commitsApi).getCommits(
                itemBankId, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        verify(pager, times(3)).hasNext();
        verify(pager, times(2)).next();
        verify(fileApi, times(3)).getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString());
    }

    @Test
    public void shouldGetRevisionsFromCreate() throws GitLabApiException, IOException {
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);

        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList1 = Lists.newArrayList(commit1, commit2);
        List<Commit> commitList2 = Lists.newArrayList(commit3);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList1).thenReturn(commitList2);
        when(commitsApi.getCommits(itemBankId, CREATE_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(pager);

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(file);
        when(fileApi.getFile(ITEM_FILE_NAME, itemBankId, MASTER_BRANCH_NAME)).thenThrow(new GitLabApiException(Response.status(404).build()));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(commitList1.size() + commitList2.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3, CREATE_BRANCH_NAME);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2, CREATE_BRANCH_NAME);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1, CREATE_BRANCH_NAME);
        verify(commitsApi).getCommits(
                itemBankId, CREATE_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        verify(pager, times(3)).hasNext();
        verify(pager, times(2)).next();
        verify(fileApi, times(4)).getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString());
    }

    /**
     * Validate the contents of an ItemBankItemRevision object
     *
     * @param revision           the object to be validated
     * @param expectedItemBankId the expected id
     * @param expectedCommit     commit object containing expected values
     */
    private void validateItemBankItemRevision(ItemBankItemRevision revision, int expectedItemBankId,
                                              Commit expectedCommit, String expectedIngestSource) {
        assertThat(expectedItemBankId).isEqualTo(revision.getItemBankId());
        assertThat(expectedCommit.getId()).isEqualTo(revision.getRevisionId());
        assertThat(expectedCommit.getCommittedDate().toInstant()).isEqualTo(revision.getRevisionDate());
        assertThat(expectedCommit.getAuthorName()).isEqualTo(revision.getAuthor());
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankPath()).isEqualTo(ITEM_BANK_PATH);
        assertThat(revision.getIngestSource()).isEqualTo(expectedIngestSource);
        assertThat(revision.isBeingCreated()).isEqualTo(CREATE_BRANCH_NAME.equals(expectedIngestSource));
    }

    @Test
    public void shouldThrowExceptionGetCommits() throws GitLabApiException {
        RuntimeException ex = new RuntimeException();
        when(commitsApi.getCommits(99, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
            .thenThrow(ex);

        try {
            client.getItemHistory(99, existingGitInfo);
            fail();
        } catch (RuntimeException re) {
            assertThat(ex).isEqualTo(re);
            verify(commitsApi).getCommits(99, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        }
    }

    @Test
    public void shouldThrowExceptionGetFile() throws GitLabApiException {
        Commit commit = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList = Lists.newArrayList(commit);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList);
        when(commitsApi.getCommits(55, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
                .thenReturn(pager);

        Exception e = new GitLabApiException("Test");
        when(fileApi.getFile(ITEM_FILE_NAME, 55, commit.getId())).thenThrow(e);

        try {
            client.getItemHistory(55, existingGitInfo);
            fail();
        } catch (RuntimeException ex) {
            assertThat(e).isEqualTo(ex.getCause());
        }
        verify(commitsApi).getCommits(55, MASTER_BRANCH_NAME, existingCommitDate, null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void shouldAddHookWhenMonitorItem() throws GitLabApiException {
        ProjectApi api = mock(ProjectApi.class);
        when(gitLabApi.getProjectApi()).thenReturn(api);
        int itemBankId = 55;
        String url = "testUrl";
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        client.monitorItem(itemBankId);
        verify(api, times(1)).addHook(itemBankId, url, true, false, false);
    }

    @Test
    public void errorWhenMonitorItem() throws GitLabApiException {
        int itemBankId = 55;
        String url = "testUrl";
        ProjectApi api = mock(ProjectApi.class);
        Exception e = new GitLabApiException("Test");
        when(gitLabApi.getProjectApi()).thenReturn(api);
        when(api.addHook(itemBankId, url, true, false, false)).thenThrow(e);
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        try {
            client.monitorItem(itemBankId);
        } catch (RuntimeException re) {
            assertThat(re.getCause()).isEqualTo(e);
            verify(api, times(1)).addHook(itemBankId, url, true, false, false);
            verify(operationalEventService, times(1)).serviceError(any(), eq(e), any(), eq(itemBankId));
        }
    }

    @Test
    public void noListenerOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // There is no listener configured. Nothing will happen
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongEventOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // Set the listener, but have the wrong type of event, nothing will happen
        client.setItemEventListener(itemEventListener);
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongGroupOnProjectCreate() {
        // Now the correct type of event, but the wrong group, nothing will happen
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath("NotTestGroup");
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group + "rest of path");
        client.onProjectEvent(createEvent);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldCreateItemOnProjectCreate() {
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath(group);
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group + "rest of path");
        createEvent.setProjectId(77);
        client.onProjectEvent(createEvent);
        verify(itemEventListener, times(1)).onCreateItem(77);
    }

    @Test
    public void noListenerOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // There is no listener configured. Nothing will happen
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);

    }

    @Test
    public void wrongGroupOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, but use the wrong branch. Nothing will happen
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/develop");
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldUpdateItemOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, use the correct branch.
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/master");
        client.onPushEvent(event);
        verify(itemEventListener, times(1)).onUpdateItem(projectId);
    }

    @Test
    public void shouldGetAllProjectIds() throws GitLabApiException {
        final ProjectApi mockProjectApi = mock(ProjectApi.class);
        final Pager mockProjectPager = mock(Pager.class);

        when(gitLabApi.getProjectApi())
            .thenReturn(mockProjectApi);
        when(mockProjectPager.hasNext())
            .thenAnswer(projectPagerHasNextAnswer());
        when(mockProjectPager.next())
            .thenAnswer(getProjectListFromPagerAnswer());
        when(mockProjectApi.getProjects(MAX_ITEMS_PER_PAGE))
            .thenReturn(mockProjectPager);

        List<Integer> result = client.getAllItemBankIds();

        verify(mockProjectApi).getProjects(MAX_ITEMS_PER_PAGE);
        verify(mockProjectPager, times(2)).next();

        assertThat(result).hasSize(101);
    }

    /**
     * Parse and Item from a json file
     *
     * @param filePath The path of the file, relative to src/test/resources
     * @return The parsed item
     * @throws IOException If something goes wrong
     */
    private String getBase64EncodedStringFromJsonFile(String filePath) throws IOException {
        URL url = getClass().getClassLoader().getResource(filePath);
        return Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(Objects.requireNonNull(url).getPath())));
    }


    /**
     * gitlab4j has a class with this name, but it is private and therefore inaccessible. Create
     * this one so we can pass it into onProjectEvent and have it detect the correct class name
     */
    private static final class CreateProjectSystemHookEvent extends ProjectSystemHookEvent {

    }

    /**
     * The first time we call hasNext(), return true.  Otherwise, return false (to simulate having no more records in
     * the mockProjectPager).
     *
     * @return An {@link org.mockito.stubbing.Answer} that represents hasNext() being called multiple times.
     */
    private Answer projectPagerHasNextAnswer() {
        return new Answer() {
            private int callCounter = 0;

            @Override
            public Object answer(final InvocationOnMock invocation) {
                return ++callCounter <= 2;
            }
        };
    }

    /**
     * Simulate returning a page of the total number of {@link org.gitlab4j.api.models.Project}s from a
     * {@link org.gitlab4j.api.Pager}.
     * <p>
     * This {@link org.mockito.stubbing.Answer} is designed to return two pages of {@link org.gitlab4j.api.models.Project}s:
     *
     * * the first page should have 100 projects
     * * the second page should have 1 project
     * </p>

     * @return The {@link org.gitlab4j.api.models.Project} that for the "page".
     */
    private Answer<List<Project>> getProjectListFromPagerAnswer() {
        final List<Project> mockProjects = new ArrayList<>();
        for (int i = 0; i < 101; i++) {
            mockProjects.add(new Project().withId(i));
        }

        return new Answer<List<Project>>() {
            int counter = 0;

            @Override
            public List<Project> answer(final InvocationOnMock invocation) {
                if (counter == 0) {
                    counter++;
                    return mockProjects.subList(0, 100);
                } else {
                    return Collections.singletonList(mockProjects.get(100));
                }
            }
        };
    }
}
