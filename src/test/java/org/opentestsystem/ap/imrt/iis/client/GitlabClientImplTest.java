package org.opentestsystem.ap.imrt.iis.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.assertj.core.util.Lists;
import org.gitlab4j.api.Pager;
import org.gitlab4j.api.models.Branch;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.ProjectHook;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.webhook.EventProject;
import org.gitlab4j.api.webhook.PushEvent;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.ItemGitInformationBuilder;
import org.opentestsystem.ap.imrt.iis.builder.TestCommitBuilder;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.exception.GitLabApiRuntimeException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.repository.GitLabRepository;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
@SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT")
// Required because findbugs is throwing errors on some of the verify statements
public class GitlabClientImplTest {
    private static final String ITEM_FILE_NAME = "item.json";
    private static final String MASTER_BRANCH_NAME = "master";
    private static final String CREATE_BRANCH_NAME = "create_user";
    private static final String ITEM_BANK_PATH = "item bank path";
    private static final int MAX_ITEMS_PER_PAGE = 100;
    private Date existingCommitDate;
    private Date zeroDate = Date.from(Instant.ofEpochSecond(0));

    @Mock
    private ItemBankProperties itemBankProperties;

    @Mock
    private ItemEventListener itemEventListener;

    @Mock
    private OperationalEventService operationalEventService;

    @Mock
    private ItemGitInformation existingGitInfo;

    @Mock
    private ImrtItem imrtItem;

    @Mock
    private Pager<Commit> emptyCommitPager;

    @Mock
    private Pager<Project> mockProjectPager;

    @Mock
    private GitLabRepository mockGitLabRepository;

    private ObjectMapper objectMapper = new ObjectMapper();

    // Object under test
    private GitlabClientImpl client;

    @Before
    public void setup() {
        when(itemBankProperties.getGroup()).thenReturn(ITEM_BANK_PATH);
        client = new GitlabClientImpl(itemBankProperties, operationalEventService, new ItemParser(objectMapper), mockGitLabRepository);

        when(existingGitInfo.getItem()).thenReturn(imrtItem);
        when(existingGitInfo.getCurrentCommitDate()).thenReturn(Instant.now());
        existingCommitDate = Date.from(existingGitInfo.getCurrentCommitDate());
        when(imrtItem.isBeingCreated()).thenReturn(false);
        when(emptyCommitPager.hasNext()).thenReturn(false);
    }

    @Test
    public void shouldReturnEmptyList() {
        when(mockGitLabRepository.findAllCommitsForFile(99, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE))
                .thenReturn(Optional.of(emptyCommitPager));

        List<ItemBankItemRevision> result = client.getItemHistory(99, existingGitInfo);

        assertThat(result).isEmpty();
        verify(mockGitLabRepository).findAllCommitsForFile(99, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE);
        verify(emptyCommitPager).hasNext();
        verify(emptyCommitPager, never()).next();
    }

    @Test
    public void historyShouldUseSinceZero() {
        int itemBankId = 77;
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, zeroDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString()))
                .thenReturn(Optional.of(new RepositoryFile()));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, null);

        assertThat(result.size()).isEqualTo(0);
        verify(mockGitLabRepository).findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString());
    }

    @Test
    public void historyShouldUseMasterBranchNotBeingCreated() {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(false);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(mockGitLabRepository).findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldUseMasterBranchItemExists() {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString()))
                .thenReturn(Optional.of(new RepositoryFile()));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(mockGitLabRepository).findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldThrowCheckingMasterBranchItemExists() {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString())).thenThrow(new GitLabApiRuntimeException("Error"));

        try {
            client.getItemHistory(itemBankId, existingGitInfo);
            fail();
        } catch (GitLabApiRuntimeException re) {
            assertThat(re.getMessage()).isEqualTo("Error");
        }
    }

    @Test
    public void historyShouldThrowFindingCreateBranch() {
        int itemBankId = 77;

        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString()))
                .thenReturn(Optional.empty());
        when(mockGitLabRepository.getAllBranches(itemBankId)).thenReturn(Lists.newArrayList());

        try {
            client.getItemHistory(itemBankId, null);
            fail();
        } catch (GitLabApiRuntimeException re) {
            verify(mockGitLabRepository).findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString());
            verify(mockGitLabRepository).getAllBranches(itemBankId);
            assertThat(re.getMessage()).isEqualTo("Could not find project for itemBank Id " + itemBankId);
        }
    }

    @Test
    public void historyShouldUseCreateBranchItemExists() {
        int itemBankId = 77;
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString())).thenReturn(Optional.empty());
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(0);
        verify(mockGitLabRepository).findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void historyShouldUseCreateBranchFindBranch() {
        int itemBankId = 77;
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, zeroDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(emptyCommitPager));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString())).thenReturn(Optional.empty());
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);
        Branch b = new Branch();
        b.setName(CREATE_BRANCH_NAME);
        when(mockGitLabRepository.getAllBranches(itemBankId)).thenReturn(Lists.newArrayList(b));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, null);

        assertThat(result.size()).isEqualTo(0);
        verify(mockGitLabRepository).findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, zeroDate, null,
                MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void shouldGetRevisionsFromMaster() throws IOException {
        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList1 = Lists.newArrayList(commit1, commit2);
        List<Commit> commitList2 = Lists.newArrayList(commit3);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList1).thenReturn(commitList2);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(pager));

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString())).thenReturn(Optional.of(file));

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(commitList1.size() + commitList2.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3, MASTER_BRANCH_NAME);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2, MASTER_BRANCH_NAME);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1, MASTER_BRANCH_NAME);
        verify(mockGitLabRepository).findAllCommitsForFile(
                itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE);
        verify(pager, times(3)).hasNext();
        verify(pager, times(2)).next();
        verify(mockGitLabRepository, times(3)).findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString());
    }

    @Test
    public void shouldGetRevisionsFromCreate() throws IOException {
        when(imrtItem.isBeingCreated()).thenReturn(true);
        when(existingGitInfo.getIngestSource()).thenReturn(CREATE_BRANCH_NAME);

        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList1 = Lists.newArrayList(commit1, commit2);
        List<Commit> commitList2 = Lists.newArrayList(commit3);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList1).thenReturn(commitList2);
        when(mockGitLabRepository.findAllCommitsForFile(itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, existingCommitDate, null,
                MAX_ITEMS_PER_PAGE)).thenReturn(Optional.of(pager));

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);
        when(mockGitLabRepository.findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString())).thenReturn(Optional.of(file));
        when(mockGitLabRepository.findFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME)).thenReturn(Optional.empty());

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, existingGitInfo);

        assertThat(result.size()).isEqualTo(commitList1.size() + commitList2.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3, CREATE_BRANCH_NAME);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2, CREATE_BRANCH_NAME);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1, CREATE_BRANCH_NAME);
        verify(mockGitLabRepository).findAllCommitsForFile(
                itemBankId, ITEM_FILE_NAME, CREATE_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE);
        verify(pager, times(3)).hasNext();
        verify(pager, times(2)).next();
        verify(mockGitLabRepository, times(4)).findFile(eq(itemBankId), eq(ITEM_FILE_NAME), anyString());
    }

    /**
     * Validate the contents of an ItemBankItemRevision object
     *
     * @param revision           the object to be validated
     * @param expectedItemBankId the expected id
     * @param expectedCommit     commit object containing expected values
     */
    private void validateItemBankItemRevision(ItemBankItemRevision revision, int expectedItemBankId,
                                              Commit expectedCommit, String expectedIngestSource) {
        assertThat(expectedItemBankId).isEqualTo(revision.getItemBankId());
        assertThat(expectedCommit.getId()).isEqualTo(revision.getRevisionId());
        assertThat(expectedCommit.getCommittedDate().toInstant()).isEqualTo(revision.getRevisionDate());
        assertThat(expectedCommit.getAuthorName()).isEqualTo(revision.getAuthor());
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankPath()).isEqualTo(ITEM_BANK_PATH);
        assertThat(revision.getIngestSource()).isEqualTo(expectedIngestSource);
        assertThat(revision.isBeingCreated()).isEqualTo(CREATE_BRANCH_NAME.equals(expectedIngestSource));
    }

    @Test
    public void shouldThrowExceptionGetCommits() {
        RuntimeException ex = new RuntimeException();
        when(mockGitLabRepository.findAllCommitsForFile(99, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE))
                .thenThrow(ex);

        try {
            client.getItemHistory(99, existingGitInfo);
            fail();
        } catch (RuntimeException re) {
            assertThat(ex).isEqualTo(re);
            verify(mockGitLabRepository).findAllCommitsForFile(99, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE);
        }
    }

    @Test
    public void shouldThrowExceptionGetFile() {
        Commit commit = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList = Lists.newArrayList(commit);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList);
        when(mockGitLabRepository.findAllCommitsForFile(55, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE))
                .thenReturn(Optional.of(pager));

        Exception e = new GitLabApiRuntimeException("Test");
        when(mockGitLabRepository.findFile(55, ITEM_FILE_NAME, MASTER_BRANCH_NAME))
                .thenThrow(e);

        try {
            client.getItemHistory(55, existingGitInfo);
        } catch (RuntimeException ex) {
            assertThat(ex).isEqualTo(e);
        }
        verify(mockGitLabRepository).findAllCommitsForFile(55, ITEM_FILE_NAME, MASTER_BRANCH_NAME, existingCommitDate, null, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void shouldAddHookWhenMonitorItem() {
        int itemBankId = 55;
        when(mockGitLabRepository.addProjectHook(itemBankId)).thenReturn(Optional.of(new ProjectHook()));
        String url = "testUrl";
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        client.monitorItem(itemBankId);
        verify(mockGitLabRepository).addProjectHook(itemBankId);
    }

    @Test
    public void errorWhenMonitorItem() {
        int itemBankId = 55;
        String url = "testUrl";
        Exception e = new GitLabApiRuntimeException("Test");
        when(mockGitLabRepository.addProjectHook(itemBankId)).thenThrow(e);
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        try {
            client.monitorItem(itemBankId);
        } catch (RuntimeException re) {
            assertThat(re).isEqualTo(e);
            verify(mockGitLabRepository).addProjectHook(itemBankId);
        }
    }

    @Test
    public void noListenerOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // There is no listener configured. Nothing will happen
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongEventOnProjectCreate() {
        final String group = "testGroup";

        final ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        event.setPathWithNamespace(group + "rest of path");

        final Namespace gitGroup = new Namespace();
        gitGroup.setPath("NotTestGroup");

        client.setItemEventListener(itemEventListener);
        client.onProjectEvent(event);

        when(itemBankProperties.getGroup()).thenReturn(group);

        client.onProjectEvent(event);

        verifyZeroInteractions(itemEventListener);
    }


    @Test
    public void shouldIgnoreProjects() {
        final String group = "testGroup";

        final CreateProjectSystemHookEvent event = new CreateProjectSystemHookEvent();
        event.setPathWithNamespace(group + "bogusProject");
        event.setPath("bogusProject");
        event.setProjectId(1);

        final Namespace gitGroup = new Namespace();
        gitGroup.setPath(group);
        when(itemBankProperties.getProjectsToIgnore()).thenReturn(Collections.singletonList("bogusProject"));

        client.setItemEventListener(itemEventListener);

        when(itemBankProperties.getGroup()).thenReturn(group);

        client.onProjectEvent(event);

        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongGroupOnProjectCreate() {
        // Now the correct type of event, but the wrong group, nothing will happen
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath("NotTestGroup");
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group + "rest of path");
        client.onProjectEvent(createEvent);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldCreateItemOnProjectCreate() {
        client.setItemEventListener(itemEventListener);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath(ITEM_BANK_PATH);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(ITEM_BANK_PATH + "rest of path");
        createEvent.setProjectId(77);
        client.onProjectEvent(createEvent);
        verify(itemEventListener, times(1)).onCreateItem(77);
    }

    @Test
    public void noListenerOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // There is no listener configured. Nothing will happen
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);

    }

    @Test
    public void wrongGroupOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, but use the wrong branch. Nothing will happen
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/develop");
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldUpdateItemOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, use the correct branch.
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/master");
        client.onPushEvent(event);
        verify(itemEventListener, times(1)).onUpdateItem(projectId);
    }

    @Test
    public void shouldIgnoreItemOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/itembankreports");
        project.setName("itembankreports");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, use the correct branch.
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/master");

        when(itemBankProperties.getProjectsToIgnore()).thenReturn(Collections.singletonList("itembankreports"));
        client.onPushEvent(event);

        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldGetAllProjectIds() {
        final int invalidProjectNumber = 77;

        Namespace gitGroup = new Namespace();
        gitGroup.setPath(ITEM_BANK_PATH);

        when(mockProjectPager.hasNext())
                .thenAnswer(projectPagerHasNextAnswer());
        when(mockProjectPager.next())
                .thenAnswer(getProjectListFromPagerAnswer(invalidProjectNumber));
        when(mockGitLabRepository.findAllProjects(MAX_ITEMS_PER_PAGE))
                .thenReturn(Optional.of(mockProjectPager));

        List<Integer> result = client.getAllItemBankIds();

        verify(mockGitLabRepository).findAllProjects(MAX_ITEMS_PER_PAGE);
        verify(mockProjectPager, times(2)).next();

        assertThat(result).hasSize(100);
        assertThat(result).doesNotContain(invalidProjectNumber);
    }

    @Test
    public void shouldGetAllProjectIdsExcludingIgnoredProjects() {
        Namespace gitGroup = new Namespace();
        gitGroup.setPath(ITEM_BANK_PATH);

        int ignoredProjectNumber = 99;
        when(itemBankProperties.getProjectsToIgnore()).thenReturn(Collections.singletonList("99"));

        when(mockProjectPager.hasNext())
                .thenAnswer(projectPagerHasNextAnswer());
        when(mockProjectPager.next())
                .thenAnswer(getProjectListFromPagerAnswer(-1));
        when(mockGitLabRepository.findAllProjects(MAX_ITEMS_PER_PAGE))
                .thenReturn(Optional.of(mockProjectPager));

        List<Integer> result = client.getAllItemBankIds();

        verify(mockGitLabRepository).findAllProjects(MAX_ITEMS_PER_PAGE);
        verify(mockProjectPager, times(2)).next();

        assertThat(result).hasSize(100);
        assertThat(result).doesNotContain(ignoredProjectNumber);
    }

    @Test
    public void shouldGetItemBankItemRevision() throws Exception {
        final ItemGitInformation itemGitInformation = new ItemGitInformationBuilder().build();
        final Commit commit = mock(Commit.class);
        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);

        when(commit.getId()).thenReturn(itemGitInformation.getCurrentCommitHash());
        when(commit.getAuthorName()).thenReturn(itemGitInformation.getItem().getItemAuthor());
        when(commit.getCommittedDate()).thenReturn(new Date());

        when(mockGitLabRepository.findCommit(itemGitInformation.getProjectId(), itemGitInformation.getCurrentCommitHash()))
                .thenReturn(Optional.of(commit));
        when(mockGitLabRepository.findFile(itemGitInformation.getProjectId(), ITEM_FILE_NAME, itemGitInformation.getIngestSource()))
                .thenReturn(Optional.of(file));

        final ItemBankItemRevision result = client.getItemBankItemRevision(itemGitInformation);

        verify(mockGitLabRepository).findCommit(itemGitInformation.getProjectId(), itemGitInformation.getCurrentCommitHash());
        verify(mockGitLabRepository).findFile(itemGitInformation.getProjectId(), ITEM_FILE_NAME, itemGitInformation.getIngestSource());

        assertThat(result.getRevisionId()).isEqualTo(itemGitInformation.getCurrentCommitHash());
        assertThat(result.getIngestSource()).isEqualTo(itemGitInformation.getIngestSource());
        assertThat(result.getItemBankId()).isEqualTo(itemGitInformation.getProjectId());
    }

    @Test
    public void shouldFindLatestRevisionOnMaster() throws IOException {
        Commit commit = new Commit();
        commit.setId("commitId");
        commit.setAuthorName("user");
        Instant now = Instant.now();
        commit.setCommittedDate(Date.from(now));

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);
        file.setCommitId("commit-1");

        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, MASTER_BRANCH_NAME)).thenReturn(Optional.of(file));
        when(mockGitLabRepository.findCommit(1, file.getCommitId())).thenReturn(Optional.of(commit));

        ItemBankItemRevision revision = client.findLatestItemBankItemRevision(1).get();

        assertThat(revision.getAuthor()).isEqualTo("user");
        assertThat(revision.getIngestSource()).isEqualTo(MASTER_BRANCH_NAME);
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankId()).isEqualTo(1);
        assertThat(revision.getRevisionId()).isEqualTo("commitId");
        assertThat(revision.getRevisionDate()).isEqualTo(now);
    }

    @Test
    public void shouldFindLatestRevisionOnCreateBranch() throws IOException {
        Commit commit = new Commit();
        commit.setId("commitId");
        commit.setAuthorName("user");
        Instant now = Instant.now();
        commit.setCommittedDate(Date.from(now));

        Branch createBranch = new Branch();
        createBranch.setName(CREATE_BRANCH_NAME);

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);
        file.setCommitId("commit-1");

        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, MASTER_BRANCH_NAME)).thenReturn(Optional.empty());
        when(mockGitLabRepository.getAllBranches(1)).thenReturn(Collections.singletonList(createBranch));
        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, createBranch.getName())).thenReturn(Optional.of(file));
        when(mockGitLabRepository.findCommit(1, file.getCommitId())).thenReturn(Optional.of(commit));

        ItemBankItemRevision revision = client.findLatestItemBankItemRevision(1).get();

        assertThat(revision.getAuthor()).isEqualTo("user");
        assertThat(revision.getIngestSource()).isEqualTo(CREATE_BRANCH_NAME);
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankId()).isEqualTo(1);
        assertThat(revision.getRevisionId()).isEqualTo("commitId");
        assertThat(revision.getRevisionDate()).isEqualTo(now);
    }

    @Test
    public void shouldReturnEmptyFindingLatestRevisionWhenNoCreateBranch() {
        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, MASTER_BRANCH_NAME)).thenReturn(Optional.empty());
        when(mockGitLabRepository.getAllBranches(1)).thenReturn(Collections.emptyList());

        assertThat(client.findLatestItemBankItemRevision(1)).isNotPresent();
    }

    @Test
    public void shouldReturnEmptyFindingLatestRevisionNoItemOnAnyBranch(){
        Branch createBranch = new Branch();
        createBranch.setName(CREATE_BRANCH_NAME);

        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, MASTER_BRANCH_NAME)).thenReturn(Optional.empty());
        when(mockGitLabRepository.getAllBranches(1)).thenReturn(Collections.singletonList(createBranch));
        when(mockGitLabRepository.findFile(1, ITEM_FILE_NAME, createBranch.getName())).thenReturn(Optional.empty());

        assertThat(client.findLatestItemBankItemRevision(1)).isNotPresent();
    }

    /**
     * Parse and Item from a json file
     *
     * @param filePath The path of the file, relative to src/test/resources
     * @return The parsed item
     * @throws IOException If something goes wrong
     */
    private String getBase64EncodedStringFromJsonFile(String filePath) throws IOException {
        URL url = getClass().getClassLoader().getResource(filePath);
        return Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(Objects.requireNonNull(url).getPath())));
    }


    /**
     * gitlab4j has a class with this name, but it is private and therefore inaccessible. Create
     * this one so we can pass it into onProjectEvent and have it detect the correct class name
     */
    private static final class CreateProjectSystemHookEvent extends ProjectSystemHookEvent {

    }

    /**
     * The first time we call hasNext(), return true.  Otherwise, return false (to simulate having no more records in
     * the mockProjectPager).
     *
     * @return An {@link org.mockito.stubbing.Answer} that represents hasNext() being called multiple times.
     */
    private Answer projectPagerHasNextAnswer() {
        return new Answer() {
            private int callCounter = 0;

            @Override
            public Object answer(final InvocationOnMock invocation) {
                return ++callCounter <= 2;
            }
        };
    }

    /**
     * Simulate returning a page of the total number of {@link org.gitlab4j.api.models.Project}s from a
     * {@link org.gitlab4j.api.Pager}.
     * <p>
     * This {@link org.mockito.stubbing.Answer} is designed to return two pages of {@link org.gitlab4j.api.models.Project}s:
     * <p>
     * * the first page should have 100 projects
     * * the second page should have 1 project
     * </p>
     *
     * @return The {@link org.gitlab4j.api.models.Project} that for the "page".
     */
    private Answer<List<Project>> getProjectListFromPagerAnswer(int numberForInvalidProject) {
        assertThat(numberForInvalidProject).isLessThan(101);

        final List<Project> mockProjects = new ArrayList<>();
        for (int i = 0; i < 101; i++) {
            Project project = new Project().withId(i);
            project.setPath(String.valueOf(i));

            if (numberForInvalidProject == i) {
                project.setPathWithNamespace("SomeOtherPath/" + i);
            } else {
                project.setPathWithNamespace(ITEM_BANK_PATH + "/" + i);
            }

            assertThat(project.getPathWithNamespace()).isNotNull();

            mockProjects.add(project);
        }

        return new Answer<List<Project>>() {
            int counter = 0;

            @Override
            public List<Project> answer(final InvocationOnMock invocation) {
                if (counter == 0) {
                    counter++;
                    return mockProjects.subList(0, 100);
                } else {
                    return Collections.singletonList(mockProjects.get(100));
                }
            }
        };
    }
}
