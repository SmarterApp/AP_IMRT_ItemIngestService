package org.opentestsystem.ap.imrt.iis.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.assertj.core.util.Lists;
import org.gitlab4j.api.CommitsApi;
import org.gitlab4j.api.GitLabApi;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.ProjectApi;
import org.gitlab4j.api.RepositoryFileApi;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.webhook.EventProject;
import org.gitlab4j.api.webhook.PushEvent;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.runners.MockitoJUnitRunner;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.TestCommitBuilder;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Base64;
import java.util.Date;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class GitlabClientImplTest {
    private static final String ITEM_FILE_NAME = "item.json";
    private static final String BRANCH_NAME = "master";
    private static final String ITEM_BANK_PATH = "item bank path";

    @Mock
    private GitLabApi gitLabApi;

    @Mock
    private ItemBankProperties itemBankProperties;

    @Mock
    private ItemEventListener itemEventListener;

    @Mock
    private OperationalEventService operationalEventService;

    private ObjectMapper objectMapper = new ObjectMapper();

    // Object under test
    private GitlabClientImpl client;

    @Before
    public void setup() {
        client = new GitlabClientImpl(itemBankProperties, operationalEventService, new ItemParser(objectMapper));
        client.setGitLabApi(gitLabApi);
    }

    @Test
    public void shouldReturnEmptyList() throws GitLabApiException {
        List<Commit> commitList = Lists.newArrayList();
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        when(api.getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME))
                .thenReturn(commitList);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        List<ItemBankItemRevision> result = client.getItemHistory(99, since);

        assertThat(result).isEmpty();
        verify(api).getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME);
    }

    @Test
    public void shouldGetRevisions() throws GitLabApiException, IOException {
        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList = Lists.newArrayList(commit1, commit2, commit3);
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        when(api.getCommits(itemBankId, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME))
                .thenReturn(commitList);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        file.setFilePath(ITEM_BANK_PATH);
        RepositoryFileApi fileApi = mock(RepositoryFileApi.class);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(file);
        when(gitLabApi.getRepositoryFileApi()).thenReturn(fileApi);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, since);
        assertThat(result.size()).isEqualTo(commitList.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1);
        verify(api).getCommits(
                itemBankId, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME);
        verify(fileApi, times(3)).getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString());
    }

    /**
     * Validate the contents of an ItemBankItemRevision object
     * @param revision the object to be validated
     * @param expectedItemBankId the expected id
     * @param expectedCommit commit object containing expected values
     */
    private void validateItemBankItemRevision(ItemBankItemRevision revision, int expectedItemBankId,
                                              Commit expectedCommit) {
        assertThat(expectedItemBankId).isEqualTo(revision.getItemBankId());
        assertThat(expectedCommit.getId()).isEqualTo(revision.getRevisionId());
        assertThat(expectedCommit.getCommittedDate().toInstant()).isEqualTo(revision.getRevisionDate());
        assertThat(expectedCommit.getAuthorName()).isEqualTo(revision.getAuthor());
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankPath()).isEqualTo(ITEM_BANK_PATH);
    }

    @Test
    public void shouldThrowExceptionGetCommits() throws GitLabApiException {
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        RuntimeException ex = new RuntimeException();
        when(api.getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME))
                .thenThrow(ex);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        try {
            client.getItemHistory(99, since);
            fail();
        } catch (RuntimeException re) {
            assertThat(ex).isEqualTo(re);
            verify(api).getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME);
        }
    }

    @Test
    public void shouldThrowExceptionGetFile() throws GitLabApiException {
        Commit commit = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList = Lists.newArrayList(commit);
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        when(api.getCommits(55, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME))
                .thenReturn(commitList);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        Exception e = new GitLabApiException("Test");
        RepositoryFileApi fileApi = mock(RepositoryFileApi.class);
        when(fileApi.getFile(ITEM_FILE_NAME, 55, commit.getId())).thenThrow(e);
        when(gitLabApi.getRepositoryFileApi()).thenReturn(fileApi);

        try {
            client.getItemHistory(55, since);
            fail();
        } catch (RuntimeException ex) {
            assertThat(e).isEqualTo(ex.getCause());
        }
        verify(api).getCommits(55, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME);
    }

    @Test
    public void shouldAddHookWhenMonitorItem() throws GitLabApiException {
        ProjectApi api = mock(ProjectApi.class);
        when(gitLabApi.getProjectApi()).thenReturn(api);
        int projectId = 55;
        String url = "testUrl";
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        client.monitorItem(projectId);
        verify(api, times(1)).addHook(projectId, url, true, false, false);
    }

    @Test
    public void errorWhenMonitorItem() throws GitLabApiException {
        int projectId = 55;
        String url = "testUrl";
        ProjectApi api = mock(ProjectApi.class);
        Exception e = new GitLabApiException("Test");
        when(gitLabApi.getProjectApi()).thenReturn(api);
        when(api.addHook(projectId, url, true, false, false)).thenThrow(e);
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        try {
            client.monitorItem(projectId);
        } catch (RuntimeException re) {
            assertThat(re.getCause()).isEqualTo(e);
            verify(api, times(1)).addHook(projectId, url, true, false, false);
            verify(operationalEventService, times(1)).serviceError(any(), eq(e), any(), eq(projectId));
        }
    }

    @Test
    public void noListenerOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // There is no listener configured. Nothing will happen
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongEventOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // Set the listener, but have the wrong type of event, nothing will happen
        client.setItemEventListener(itemEventListener);
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongGroupOnProjectCreate() {
        // Now the correct type of event, but the wrong group, nothing will happen
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath("NotTestGroup");
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group+"rest of path");
        client.onProjectEvent(createEvent);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldCreateItemOnProjectCreate() {
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath(group);
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group+"rest of path");
        createEvent.setProjectId(77);
        client.onProjectEvent(createEvent);
        verify(itemEventListener, times(1)).onCreateItem(77);
    }

    @Test
    public void noListenerOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // There is no listener configured. Nothing will happen
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);

    }

    @Test
    public void wrongGroupOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

         // Set the listener, but use the wrong branch. Nothing will happen
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/develop");
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldUpdateItemOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, use the correct branch.
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/master");
        client.onPushEvent(event);
        verify(itemEventListener, times(1)).onUpdateItem(projectId);
    }

    /**
     * Parse and Item from a json file
     * @param filePath  The path of the file, relative to src/test/resources
     * @return  The parsed item
     * @throws IOException  If something goes wrong
     */
    private String getBase64EncodedStringFromJsonFile(String filePath) throws IOException {
        URL url = getClass().getClassLoader().getResource(filePath);
        return Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(url.getPath())));
    }


    /**
     * gitlab4j has a class with this name, but it is private and therefore inaccessible. Create
     * this one so we can pass it into onProjectEvent and have it detect the correct class name
     */
    private static final class CreateProjectSystemHookEvent extends ProjectSystemHookEvent {

    }
}
