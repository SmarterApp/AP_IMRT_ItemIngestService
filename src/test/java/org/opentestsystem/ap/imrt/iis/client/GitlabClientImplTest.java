package org.opentestsystem.ap.imrt.iis.client;

import com.fasterxml.jackson.databind.ObjectMapper;
import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import org.assertj.core.util.Lists;
import org.gitlab4j.api.CommitsApi;
import org.gitlab4j.api.GitLabApi;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.Pager;
import org.gitlab4j.api.ProjectApi;
import org.gitlab4j.api.RepositoryFileApi;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.webhook.EventProject;
import org.gitlab4j.api.webhook.PushEvent;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.stubbing.Answer;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.builder.TestCommitBuilder;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Objects;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.Assert.fail;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyZeroInteractions;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
@SuppressFBWarnings("RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT")
// Required because findbugs is throwing errors on some of the verify statements
public class GitlabClientImplTest {
    private static final String ITEM_FILE_NAME = "item.json";
    private static final String BRANCH_NAME = "master";
    private static final String ITEM_BANK_PATH = "item bank path";
    private static final int MAX_ITEMS_PER_PAGE = 100;

    @Mock
    private GitLabApi gitLabApi;

    @Mock
    private ItemBankProperties itemBankProperties;

    @Mock
    private ItemEventListener itemEventListener;

    @Mock
    private OperationalEventService operationalEventService;

    private ObjectMapper objectMapper = new ObjectMapper();

    // Object under test
    private GitlabClientImpl client;

    @Before
    public void setup() {
        when(itemBankProperties.getGroup()).thenReturn(ITEM_BANK_PATH);
        client = new GitlabClientImpl(itemBankProperties, operationalEventService, new ItemParser(objectMapper));
        client.setGitLabApi(gitLabApi);
    }

    @Test
    public void shouldReturnEmptyList() throws GitLabApiException {
        CommitsApi api = mock(CommitsApi.class);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(false);
        Instant since = Instant.now();
        when(api.getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
                .thenReturn(pager);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        List<ItemBankItemRevision> result = client.getItemHistory(99, since);

        assertThat(result).isEmpty();
        verify(api).getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        verify(pager).hasNext();
        verify(pager, never()).next();
    }

    @Test
    public void shouldGetRevisions() throws GitLabApiException, IOException {
        int itemBankId = 77;
        Commit commit1 = new TestCommitBuilder().withId("1").withAuthor("author1").build();
        Commit commit2 = new TestCommitBuilder().withId("2").withAuthor("author2").build();
        Commit commit3 = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList1 = Lists.newArrayList(commit1, commit2);
        List<Commit> commitList2 = Lists.newArrayList(commit3);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList1).thenReturn(commitList2);
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        when(api.getCommits(itemBankId, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME,
                MAX_ITEMS_PER_PAGE)).thenReturn(pager);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        RepositoryFile file = new RepositoryFile();
        file.setContent(getBase64EncodedStringFromJsonFile("json/good-item.json"));
        RepositoryFileApi fileApi = mock(RepositoryFileApi.class);
        when(fileApi.getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString())).thenReturn(file);
        when(gitLabApi.getRepositoryFileApi()).thenReturn(fileApi);

        List<ItemBankItemRevision> result = client.getItemHistory(itemBankId, since);
        assertThat(result.size()).isEqualTo(commitList1.size() + commitList2.size());
        // Check the results, the order should be reversed
        validateItemBankItemRevision(result.get(0), itemBankId, commit3);
        validateItemBankItemRevision(result.get(1), itemBankId, commit2);
        validateItemBankItemRevision(result.get(2), itemBankId, commit1);
        verify(api).getCommits(
                itemBankId, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        verify(pager, times(3)).hasNext();
        verify(pager, times(2)).next();
        verify(fileApi, times(3)).getFile(eq(ITEM_FILE_NAME), eq(itemBankId), anyString());
    }

    /**
     * Validate the contents of an ItemBankItemRevision object
     *
     * @param revision           the object to be validated
     * @param expectedItemBankId the expected id
     * @param expectedCommit     commit object containing expected values
     */
    private void validateItemBankItemRevision(ItemBankItemRevision revision, int expectedItemBankId,
                                              Commit expectedCommit) {
        assertThat(expectedItemBankId).isEqualTo(revision.getItemBankId());
        assertThat(expectedCommit.getId()).isEqualTo(revision.getRevisionId());
        assertThat(expectedCommit.getCommittedDate().toInstant()).isEqualTo(revision.getRevisionDate());
        assertThat(expectedCommit.getAuthorName()).isEqualTo(revision.getAuthor());
        assertThat(revision.getItem()).isNotNull();
        assertThat(revision.getItemBankPath()).isEqualTo(ITEM_BANK_PATH);
    }

    @Test
    public void shouldThrowExceptionGetCommits() throws GitLabApiException {
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        RuntimeException ex = new RuntimeException();
        when(api.getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
                .thenThrow(ex);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        try {
            client.getItemHistory(99, since);
            fail();
        } catch (RuntimeException re) {
            assertThat(ex).isEqualTo(re);
            verify(api).getCommits(99, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
        }
    }

    @Test
    public void shouldThrowExceptionGetFile() throws GitLabApiException {
        Commit commit = new TestCommitBuilder().withId("3").withAuthor("author3").build();
        List<Commit> commitList = Lists.newArrayList(commit);
        @SuppressWarnings("unchecked")
        Pager<Commit> pager = mock(Pager.class);
        when(pager.hasNext()).thenReturn(true).thenReturn(false);
        when(pager.next()).thenReturn(commitList);
        CommitsApi api = mock(CommitsApi.class);
        Instant since = Instant.now();
        when(api.getCommits(55, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE))
                .thenReturn(pager);
        when(gitLabApi.getCommitsApi()).thenReturn(api);

        Exception e = new GitLabApiException("Test");
        RepositoryFileApi fileApi = mock(RepositoryFileApi.class);
        when(fileApi.getFile(ITEM_FILE_NAME, 55, commit.getId())).thenThrow(e);
        when(gitLabApi.getRepositoryFileApi()).thenReturn(fileApi);

        try {
            client.getItemHistory(55, since);
            fail();
        } catch (RuntimeException ex) {
            assertThat(e).isEqualTo(ex.getCause());
        }
        verify(api).getCommits(55, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
    }

    @Test
    public void shouldAddHookWhenMonitorItem() throws GitLabApiException {
        ProjectApi api = mock(ProjectApi.class);
        when(gitLabApi.getProjectApi()).thenReturn(api);
        int itemBankId = 55;
        String url = "testUrl";
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        client.monitorItem(itemBankId);
        verify(api, times(1)).addHook(itemBankId, url, true, false, false);
    }

    @Test
    public void errorWhenMonitorItem() throws GitLabApiException {
        int itemBankId = 55;
        String url = "testUrl";
        ProjectApi api = mock(ProjectApi.class);
        Exception e = new GitLabApiException("Test");
        when(gitLabApi.getProjectApi()).thenReturn(api);
        when(api.addHook(itemBankId, url, true, false, false)).thenThrow(e);
        when(itemBankProperties.getWebhookUrl()).thenReturn(url);
        try {
            client.monitorItem(itemBankId);
        } catch (RuntimeException re) {
            assertThat(re.getCause()).isEqualTo(e);
            verify(api, times(1)).addHook(itemBankId, url, true, false, false);
            verify(operationalEventService, times(1)).serviceError(any(), eq(e), any(), eq(itemBankId));
        }
    }

    @Test
    public void noListenerOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // There is no listener configured. Nothing will happen
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongEventOnProjectCreate() {
        ProjectSystemHookEvent event = new ProjectSystemHookEvent();
        // Set the listener, but have the wrong type of event, nothing will happen
        client.setItemEventListener(itemEventListener);
        client.onProjectEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void wrongGroupOnProjectCreate() {
        // Now the correct type of event, but the wrong group, nothing will happen
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath("NotTestGroup");
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group + "rest of path");
        client.onProjectEvent(createEvent);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldCreateItemOnProjectCreate() {
        client.setItemEventListener(itemEventListener);
        String group = "testGroup";
        when(itemBankProperties.getGroup()).thenReturn(group);
        Namespace gitGroup = new Namespace();
        gitGroup.setPath(group);
        client.setGroup(gitGroup);
        CreateProjectSystemHookEvent createEvent = new CreateProjectSystemHookEvent();
        createEvent.setPathWithNamespace(group + "rest of path");
        createEvent.setProjectId(77);
        client.onProjectEvent(createEvent);
        verify(itemEventListener, times(1)).onCreateItem(77);
    }

    @Test
    public void noListenerOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // There is no listener configured. Nothing will happen
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);

    }

    @Test
    public void wrongGroupOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, but use the wrong branch. Nothing will happen
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/develop");
        client.onPushEvent(event);
        verifyZeroInteractions(itemEventListener);
    }

    @Test
    public void shouldUpdateItemOnPushEvent() {
        int projectId = 99;
        PushEvent event = new PushEvent();
        EventProject project = new EventProject();
        project.setPathWithNamespace("testGroup/22");
        event.setProject(project);
        event.setProjectId(projectId);

        // Set the listener, use the correct branch.
        client.setItemEventListener(itemEventListener);
        event.setRef("refs/heads/master");
        client.onPushEvent(event);
        verify(itemEventListener, times(1)).onUpdateItem(projectId);
    }

    @Test
    public void shouldGetAllProjectIds() throws GitLabApiException {
        final ProjectApi mockProjectApi = mock(ProjectApi.class);
        final Pager mockProjectPager = mock(Pager.class);
        final int invalidProjectNumber = 77;

        Namespace gitGroup = new Namespace();
        gitGroup.setPath(ITEM_BANK_PATH);
        client.setGroup(gitGroup);

        when(gitLabApi.getProjectApi())
                .thenReturn(mockProjectApi);
        when(mockProjectPager.hasNext())
                .thenAnswer(projectPagerHasNextAnswer());
        when(mockProjectPager.next())
                .thenAnswer(getProjectListFromPagerAnswer(invalidProjectNumber));
        when(mockProjectApi.getProjects(MAX_ITEMS_PER_PAGE))
                .thenReturn(mockProjectPager);

        List<Integer> result = client.getAllItemBankIds();

        verify(mockProjectApi).getProjects(MAX_ITEMS_PER_PAGE);
        verify(mockProjectPager, times(2)).next();

        assertThat(result).hasSize(100);
        assertThat(result).doesNotContain(invalidProjectNumber);
    }

    /**
     * Parse and Item from a json file
     *
     * @param filePath The path of the file, relative to src/test/resources
     * @return The parsed item
     * @throws IOException If something goes wrong
     */
    private String getBase64EncodedStringFromJsonFile(String filePath) throws IOException {
        URL url = getClass().getClassLoader().getResource(filePath);
        return Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(Objects.requireNonNull(url).getPath())));
    }


    /**
     * gitlab4j has a class with this name, but it is private and therefore inaccessible. Create
     * this one so we can pass it into onProjectEvent and have it detect the correct class name
     */
    private static final class CreateProjectSystemHookEvent extends ProjectSystemHookEvent {

    }

    /**
     * The first time we call hasNext(), return true.  Otherwise, return false (to simulate having no more records in
     * the mockProjectPager).
     *
     * @return An {@link org.mockito.stubbing.Answer} that represents hasNext() being called multiple times.
     */
    private Answer projectPagerHasNextAnswer() {
        return new Answer() {
            private int callCounter = 0;

            @Override
            public Object answer(final InvocationOnMock invocation) {
                return ++callCounter <= 2;
            }
        };
    }

    /**
     * Simulate returning a page of the total number of {@link org.gitlab4j.api.models.Project}s from a
     * {@link org.gitlab4j.api.Pager}.
     * <p>
     * This {@link org.mockito.stubbing.Answer} is designed to return two pages of {@link org.gitlab4j.api.models.Project}s:
     * <p>
     * * the first page should have 100 projects
     * * the second page should have 1 project
     * </p>
     *
     * @return The {@link org.gitlab4j.api.models.Project} that for the "page".
     */
    private Answer<List<Project>> getProjectListFromPagerAnswer(int numberForInvalidProject) {
        assertThat(numberForInvalidProject).isLessThan(101);

        final List<Project> mockProjects = new ArrayList<>();
        for (int i = 0; i < 101; i++) {
            Project project = new Project().withId(i);

            if (numberForInvalidProject == i) {
                project.setPathWithNamespace("SomeOtherPath/" + i);
            } else {
                project.setPathWithNamespace(ITEM_BANK_PATH + "/" + i);
            }

            assertThat(project.getPathWithNamespace()).isNotNull();

            mockProjects.add(project);
        }

        return new Answer<List<Project>>() {
            int counter = 0;

            @Override
            public List<Project> answer(final InvocationOnMock invocation) {
                if (counter == 0) {
                    counter++;
                    return mockProjects.subList(0, 100);
                } else {
                    return Collections.singletonList(mockProjects.get(100));
                }
            }
        };
    }
}
