package org.opentestsystem.ap.imrt.iis.batch.impl;

import org.opentestsystem.ap.common.imrt.exception.NotFoundException;
import org.opentestsystem.ap.imrt.iis.exception.JobAbandonmentException;
import org.opentestsystem.ap.imrt.iis.model.JobExecutionResponse;
import org.opentestsystem.ap.imrt.iis.batch.SpringBatchJobManagementService;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionException;
import org.springframework.batch.core.JobInstance;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobOperator;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;


@Service
public class SpringBatchJobManagementServiceImpl implements SpringBatchJobManagementService {
    private final JobExplorer jobExplorer;
    private final JobOperator jobOperator;

    public SpringBatchJobManagementServiceImpl(final JobExplorer jobExplorer, final JobOperator jobOperator) {
        this.jobExplorer = jobExplorer;
        this.jobOperator = jobOperator;
    }

    @Override
    public JobExecutionResponse abandon(final long jobInstanceId) {
        final JobInstance jobInstance = Optional.ofNullable(jobExplorer.getJobInstance(jobInstanceId))
                .orElseThrow(() -> new NotFoundException(String.format("Could not find job instance for instance id %d", jobInstanceId)));

        final Set<JobExecution> runningJobExecutions = jobExplorer.findRunningJobExecutions(jobInstance.getJobName());

        // If more than one running job execution is found, throw exception.  Based on how the the jobs are configured,
        // this should never happen
        if (runningJobExecutions.size() > 1) {
            final List<Long> runningExecutionIds = runningJobExecutions.stream()
                    .map(JobExecution::getId)
                    .collect(Collectors.toList());

            throw new IllegalStateException(String.format("Found more than one running execution for the %s.  Job execution ids in running state: %s",
                    jobInstance.getJobName(),
                    runningExecutionIds));
        }

        if (runningJobExecutions.isEmpty()) {
            return new JobExecutionResponse(0L,
                    jobInstance.getId(),
                    jobInstance.getJobName(),
                    "NO JOB EXECUTIONS",
                    String.format("No job executions are currently running for the %s (job instance id %d)",
                            jobInstance.getJobName(),
                            jobInstance.getId()));
        }

        final JobExecution executionToAbandon = runningJobExecutions.iterator().next();

        // A job execution in a "running" (e.g. status == "STARTED") state cannot be abandoned; it must be stopped
        // first.
        if (executionToAbandon.isRunning()) {
            try {
                jobOperator.stop(executionToAbandon.getId());
            } catch (final JobExecutionException e) {
                throw new JobAbandonmentException(String.format("Could not stop job execution %d", executionToAbandon.getId()), e);
            }
        }

        try {
            jobOperator.abandon(executionToAbandon.getId());
        } catch (final JobExecutionException e) {
            throw new JobAbandonmentException(String.format("Could not abandon job execution %d", executionToAbandon.getId()), e);
        }

        // Fetch the job execution again to get the updated status
        final JobExecution abandonedJobExecution = jobExplorer.getJobExecution(executionToAbandon.getId());

        return new JobExecutionResponse(abandonedJobExecution.getId(),
                abandonedJobExecution.getJobInstance().getId(),
                abandonedJobExecution.getJobInstance().getJobName(),
                abandonedJobExecution.getStatus().toString(),
                String.format("Job Execution %d for Job %s abandoned successfully",
                        abandonedJobExecution.getId(),
                        abandonedJobExecution.getJobInstance().getJobName()));
    }
}
