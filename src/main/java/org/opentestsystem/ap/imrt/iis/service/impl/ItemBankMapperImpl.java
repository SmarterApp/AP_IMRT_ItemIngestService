package org.opentestsystem.ap.imrt.iis.service.impl;

import com.google.common.primitives.Ints;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.ap.common.model.AbstractAssessmentItemCore;
import org.opentestsystem.ap.common.model.Administration;
import org.opentestsystem.ap.common.model.AssessmentItemCore;
import org.opentestsystem.ap.common.model.FieldTestData;
import org.opentestsystem.ap.common.model.Form;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.model.ItemConstants;
import org.opentestsystem.ap.common.model.ItemMetadata;
import org.opentestsystem.ap.common.model.StimItem;
import org.opentestsystem.ap.common.model.TestAdministration;
import org.opentestsystem.ap.imrt.common.model.Attachment;
import org.opentestsystem.ap.imrt.common.model.AttachmentFileTypes;
import org.opentestsystem.ap.imrt.common.model.AttachmentKey;
import org.opentestsystem.ap.imrt.common.model.BaseItem;
import org.opentestsystem.ap.imrt.common.model.ContentUpdateNeed;
import org.opentestsystem.ap.imrt.common.model.ImrtItem;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.model.ItemLog;
import org.opentestsystem.ap.imrt.common.model.ItemLogKey;
import org.opentestsystem.ap.imrt.common.model.Stimulus;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.service.ItemBankMapper;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import static org.apache.commons.lang.StringUtils.defaultString;
import static org.apache.commons.lang.StringUtils.isNotBlank;
import static org.springframework.util.StringUtils.isEmpty;

/**
 * Implementation of ItemRevision interface that converts from AP common domain
 * model, with some associated git information, into IMRT domain model objects
 */
@Component
public final class ItemBankMapperImpl implements ItemBankMapper {
    public ItemRevision map(ItemBankItemRevision itemBankItemRevision, ItemGitInformation existingItemGitInformation) {
        Item item = itemBankItemRevision.getItem();
        ItemInformation itemInformation = getItemInformation(item);
        BaseItem baseItem;

        if (existingItemGitInformation == null) {
            baseItem = ItemConstants.ItemType.TYPE_STIM.equals(item.getType()) ? new Stimulus() : new ImrtItem();

            baseItem.setId(convertItemId(item.getId()));
        } else {
            baseItem = existingItemGitInformation.getItem();
        }

        updateBaseItem(baseItem, itemInformation, existingItemGitInformation, itemBankItemRevision);
        ItemGitInformation itemGitInformation = createItemGitInformation(baseItem, itemBankItemRevision);
        ItemLog itemLog = createItemLog(baseItem, itemBankItemRevision);

        return ItemRevision.builder()
                .withBaseItem(baseItem)
                .withItemGitInformation(itemGitInformation)
                .withItemLog(itemLog)
                .withLinkedStimulusId(itemInformation.getStimulusId().orElse(null))
                .withExistingItem(existingItemGitInformation != null)
                .build();
    }

    /**
     * Finds the ItemMetadata by inspecting the type of the item. Stores it
     * in the metadata field. Also stores linkedStimulusId if found.
     */
    private ItemInformation getItemInformation(Item item) {
        if (item.getCore() instanceof AbstractAssessmentItemCore) {
            AbstractAssessmentItemCore core = (AbstractAssessmentItemCore) item.getCore();
            ItemMetadata metadata = core.getMetadata();
            String stimulusId = core.getStimulusId();
            Integer linkedStimulusId = null;
            if (!isEmpty(stimulusId)) {
                linkedStimulusId = convertItemId(stimulusId);
            }

            return new ItemInformation(item, metadata, linkedStimulusId);
        } else if (item.getCore() != null) {
            ItemMetadata metadata = item.getCore().getMetadata();
            return new ItemInformation(item, metadata);
        }

        return new ItemInformation(item);
    }

    /**
     * Creates an ImrtItem from the item bank data and stores it in the
     * baseItem field.
     */
    private void updateBaseItem(
            final BaseItem baseItem,
            final ItemInformation itemInformation,
            final ItemGitInformation existingItemGitInformation,
            final ItemBankItemRevision itemBankItemRevision) {
        final Item item = itemInformation.getItem();

        baseItem.setItemJson(item);
        baseItem.setItemType(item.getType());
        baseItem.setUpdatedBy(itemBankItemRevision.getAuthor());
        baseItem.setBeingCreated(itemBankItemRevision.isBeingCreated());
        baseItem.setEnglishContentLastUpdatedAt(item.getCore().getEn().getUpdatedDate().toInstant());

        if (itemInformation.getStimulusId().isPresent()) {
            baseItem.setAssociatedStimulusId(itemInformation.getStimulusId().get());
        }

        if (item.getWorkflow() != null) {
            baseItem.setWorkflowStatus(defaultString(item.getWorkflow().getWorkflowStatusCode()));
        }

        // Metadata may be null if this is a tutorial item
        if (itemInformation.getItemMetadata().isPresent()) {
            ItemMetadata metadata = itemInformation.getItemMetadata().get();
            baseItem.setSubject(defaultString(metadata.getSubject()));
            baseItem.setGrade(defaultString(metadata.getIntendedGrade()));
            baseItem.setDepthOfKnowledge(defaultString(metadata.getDepthOfKnowledge()));
            baseItem.setOrganizationTypeId(defaultString(metadata.getOrganizationTypeId()));
            baseItem.setOrganizationName(defaultString(metadata.getOrganizationName()));
            baseItem.setContentTaskModel(defaultString(metadata.getContentTaskModel()));
            baseItem.setPerformanceTask(defaultString(metadata.getPerformanceTask()));
            baseItem.setWritingPurpose(defaultString(metadata.getWritingPurpose()));
            baseItem.setItemAuthor(defaultString(metadata.getItemAuthor()));
            baseItem.setTestCategory(defaultString(metadata.getTestCategory()));
            baseItem.setScoringEngine(defaultString(metadata.getScoringEngine()));
            baseItem.setAllowCalculator(defaultString(metadata.getAllowCalculator()));
        }

        if (null == existingItemGitInformation) {
            // We have never seen this item before, so set the creation info from this commit
            baseItem.setItemCreatedBy(itemBankItemRevision.getAuthor());
            baseItem.setItemCreatedAt(itemBankItemRevision.getRevisionDate());
            baseItem.setWorkflowStatusSetAt(itemBankItemRevision.getRevisionDate());
        } else {
            BaseItem existingImrtItem = existingItemGitInformation.getItem();
            baseItem.setItemCreatedBy(existingImrtItem.getItemCreatedBy());
            baseItem.setItemCreatedAt(existingImrtItem.getItemCreatedAt());
            baseItem.setWorkflowStatusSetAt(existingImrtItem.getWorkflowStatusSetAt());
            baseItem.setKey(existingImrtItem.getKey());
        }

        if (item.getTextToSpeech() != null) {
            baseItem.setVisualTtsRequired(defaultString(item.getTextToSpeech().getVisualTTSRequired()));
            baseItem.setVisualTtsProvided(item.getTextToSpeech().isVisualTTSProvided());
            baseItem.setSightTtsProvided(item.getTextToSpeech().isSightTTSProvided());
        }

        populateItemWithAdministrationData(item, baseItem);
        populateItemWithContentRequiredData(item, baseItem);
        updateItemStandardIds(baseItem, itemInformation);
        updatePassageCounts(baseItem, item);

        baseItem.setContentUpdateNeeds(getContentUpdatedNeed(baseItem, item, itemBankItemRevision.getAuthor()));
    }

    /**
     * Set the content required fields for the {@link org.opentestsystem.ap.imrt.common.model.BaseItem}.
     */
    private void populateItemWithContentRequiredData(final Item item, final BaseItem baseItem) {
        Collection<Attachment> iatAttachments = new HashSet<>();

        if (item.getAsl() != null) {
            baseItem.setAslRequired(defaultString(item.getAsl().getAslRequired()));
            baseItem.setAslProvided(String.valueOf(item.getAsl().isAslProvided()));
            final Attachments aslAttachments = getContentAttachments(baseItem,
                    item.getAsl().getAttachments(),
                    AttachmentFileTypes.ASL);

            iatAttachments.addAll(aslAttachments.getAttachments());
            aslAttachments.getMostRecentUploadDate()
                    .ifPresent(maxUploadDate ->
                            baseItem.setAslUploadedPriorToLastContentUpdate(maxUploadDate.isBefore(baseItem.getEnglishContentLastUpdatedAt())));
        }

        if (item.getBraille() != null) {
            baseItem.setBrailleRequired(item.getBraille().getBrailleRequired());
            baseItem.setBrailleProvided(String.valueOf(item.getBraille().isBrailleProvided()));
            final Attachments brailleAttachments = getContentAttachments(baseItem,
                    item.getBraille().getAttachments(),
                    AttachmentFileTypes.BRAILLE);

            iatAttachments.addAll(brailleAttachments.getAttachments());
            brailleAttachments.getMostRecentUploadDate()
                    .ifPresent(maxUploadDate ->
                            baseItem.setBrailleUploadedPriorToLastContentUpdate(maxUploadDate.isBefore(baseItem.getEnglishContentLastUpdatedAt())));
        }

        if (item.getCc() != null) {
            baseItem.setCcRequired(item.getCc().getCcRequired());
            baseItem.setCcProvided(String.valueOf(item.getCc().isCcProvided()));
            final Attachments closedCaptioningAttachments = getContentAttachments(baseItem,
                    item.getCc().getAttachments(),
                    AttachmentFileTypes.CC);

            iatAttachments.addAll(closedCaptioningAttachments.getAttachments());
            closedCaptioningAttachments.getMostRecentUploadDate()
                    .ifPresent(maxUploadDate ->
                            baseItem.setClosedCaptioningUploadedPriorToLastContentUpdate(maxUploadDate.isBefore(baseItem.getEnglishContentLastUpdatedAt())));
        }

        baseItem.getAttachments().retainAll(iatAttachments);

        for (Attachment iatAttachment : iatAttachments) {
            if (!baseItem.getAttachments().contains(iatAttachment)) {
                baseItem.getAttachments().add(iatAttachment);
                continue;
            }

            Attachment imrtAttachment = baseItem.getAttachments()
                    .stream()
                    .filter(attachment -> attachment.getAttachmentKey().equals(attachment.getAttachmentKey()))
                    .findFirst()
                    .orElseThrow(() -> new RuntimeException("Could not find attachment for attachment key " + iatAttachment.getAttachmentKey()));

            imrtAttachment.setUploadedDate(iatAttachment.getUploadedDate());
            imrtAttachment.setCreatedAt(iatAttachment.getCreatedAt());
            imrtAttachment.setUpdatedAt(iatAttachment.getUpdatedAt());
            imrtAttachment.setUpdatedBy(iatAttachment.getUpdatedBy());
        }

        if (item.getTranslations() != null) {
            baseItem.setTranslationRequired(item.getTranslations().getEsp().isRequired());
            baseItem.setTranslationProvided(String.valueOf(item.getTranslations().getEsp().isProvided()));
            baseItem.setSpanishContentLastUpdatedAt(item.getTranslations().getEsp().getUpdatedDate().toInstant());
        }
    }

    /**
     * Creates ItemGitInformation from the item bank data and stores it in
     * the itemGitInformation field
     */
    private ItemGitInformation createItemGitInformation(BaseItem baseItem, ItemBankItemRevision itemBankItemRevision) {
        ItemGitInformation itemGitInformation = new ItemGitInformation();
        itemGitInformation.setItem(baseItem);
        itemGitInformation.setProjectId(itemBankItemRevision.getItemBankId());
        itemGitInformation.setProjectPath(itemBankItemRevision.getItemBankPath());
        itemGitInformation.setCurrentCommitDate(itemBankItemRevision.getRevisionDate());
        itemGitInformation.setCurrentCommitHash(itemBankItemRevision.getRevisionId());
        itemGitInformation.setUpdatedBy(itemBankItemRevision.getAuthor());
        itemGitInformation.setIngestSource(itemBankItemRevision.getIngestSource());

        return itemGitInformation;
    }

    private void updateItemStandardIds(BaseItem item, ItemInformation itemInformation) {
        if (!itemInformation.getItemMetadata().isPresent()) {
            return;
        }

        final ItemMetadata metadata = itemInformation.getItemMetadata().get();

        item.setPrimaryClaim(defaultString(metadata.getPrimaryClaim()));
        item.setPrimaryTarget(defaultString(metadata.getPrimaryTarget()));
        item.setPrimaryCommonCoreStandard(defaultString(metadata.getPrimaryCommonCoreStandard()));
        item.setPrimaryContentDomain(defaultString(metadata.getPrimaryContentDomain()));
        item.setSecondaryClaim(defaultString(metadata.getSecondaryClaim()));
        item.setSecondaryCommonCoreStandard(defaultString(metadata.getSecondaryCommonCoreStandard()));
        item.setSecondaryContentDomain(defaultString(metadata.getSecondaryContentDomain()));
        item.setSecondaryTarget(defaultString(metadata.getSecondaryTarget()));
        item.setTertiaryClaim(defaultString(metadata.getTertiaryClaim()));
        item.setTertiaryCommonCoreStandard(defaultString(metadata.getTertiaryCommonCoreStandard()));
        item.setTertiaryContentDomain(defaultString(metadata.getTertiaryContentDomain()));
        item.setTertiaryTarget(defaultString(metadata.getTertiaryTarget()));
        item.setQuaternaryClaim(defaultString(metadata.getQuaternaryClaim()));
        item.setQuaternaryCommonCoreStandard(defaultString(metadata.getQuaternaryCommonCoreStandard()));
        item.setQuaternaryContentDomain(defaultString(metadata.getQuaternaryContentDomain()));
        item.setQuaternaryTarget(defaultString(metadata.getQuaternaryTarget()));
    }

    private void populateItemWithAdministrationData(Item item, BaseItem baseItem) {
        if (!(item.getCore() instanceof AssessmentItemCore)) {
            baseItem.setExposuresCount(null);
            baseItem.setItemDifficultyQuintile(null);
            return;
        }

        TestAdministration testAdministration = ((AssessmentItemCore) item.getCore()).getTestAdministration();

        //If the item has not been included in an administration them we cannot capture the data.
        if (testAdministration == null
                || testAdministration.getAdministrations() == null
                || testAdministration.getAdministrations().isEmpty()) {
            baseItem.setExposuresCount(null);
            baseItem.setItemDifficultyQuintile(null);
            return;
        }

        final String fieldTestDataId = testAdministration.getFieldTestAdministrationId();
        int exposuresCount = 0;
        Optional<FieldTestData> fieldTestData = Optional.empty();

        baseItem.getForms().clear();

        for (Administration administration : testAdministration.getAdministrations()) {
            if (StringUtils.equals(administration.getAdministrationId(), fieldTestDataId)) {
                fieldTestData = Optional.of(administration.getFieldTestData());
            }

            for (Form form : administration.getForms()) {
                if (form.getExposures() != null) {
                    exposuresCount += form.getExposures();
                }

                org.opentestsystem.ap.imrt.common.model.Form itemForm = new org.opentestsystem.ap.imrt.common.model.Form();
                itemForm.setFormId(defaultString(form.getFormId()));
                itemForm.setFormType(defaultString(form.getFormType()));
                itemForm.setAssessmentType(defaultString(form.getAssessmentType()));
                itemForm.setExposures(form.getExposures());
                itemForm.setItem(baseItem);
                itemForm.setUpdatedBy(baseItem.getUpdatedBy());
                baseItem.getForms().add(itemForm);
            }
        }

        baseItem.setExposuresCount(exposuresCount);

        if (fieldTestData.isPresent() && isNotBlank(fieldTestData.get().getItemDifficultyQuintile())) {
            baseItem.setItemDifficultyQuintile(Ints.tryParse(fieldTestData.get().getItemDifficultyQuintile()));
        }
    }


    private ItemLog createItemLog(BaseItem baseItem, ItemBankItemRevision itemBankItemRevision) {
        ItemLogKey itemLogKey = new ItemLogKey(baseItem, itemBankItemRevision.getRevisionId());
        ItemLog itemLog = new ItemLog();
        itemLog.setItemLogKey(itemLogKey);
        itemLog.setCommitDate(itemBankItemRevision.getRevisionDate());
        itemLog.setUpdatedBy(itemBankItemRevision.getAuthor());
        itemLog.setIngestSource(itemBankItemRevision.getIngestSource());

        return itemLog;
    }

    private static Integer convertItemId(String id) throws IllegalArgumentException {
        try {
            return Integer.valueOf(id);
        } catch (NumberFormatException nfe) {
            throw new IllegalArgumentException("The id is not a number and cannot be ingested into the system");
        }
    }

    private Attachments getContentAttachments(final BaseItem item,
                                              final List<org.opentestsystem.ap.common.model.Attachment> iatAttachments,
                                              final String fileType) {
        final Set<Attachment> attachments = new HashSet<>();
        Instant mostRecentUploadDate = null;
        for (org.opentestsystem.ap.common.model.Attachment iatAttachment : iatAttachments) {
            if (mostRecentUploadDate == null) {
                mostRecentUploadDate = iatAttachment.getUploadedDate().toInstant();
            }

            final Attachment attachment = new Attachment(new AttachmentKey(item, iatAttachment.getFileName(), fileType),
                    iatAttachment.getUploadedDate().toInstant(),
                    item.getUpdatedBy());

            if (mostRecentUploadDate != null && attachment.getUploadedDate().isAfter(mostRecentUploadDate)) {
                mostRecentUploadDate = attachment.getUploadedDate();
            }

            attachments.add(attachment);
        }

        return new Attachments(attachments, mostRecentUploadDate);
    }

    private void updatePassageCounts(BaseItem item, Item iatItem) {
        if (iatItem instanceof StimItem) {
            StimItem stim = (StimItem) iatItem;
            item.setEnglishPassagesCount(stim.getCore().getEn().getPassages().size());
            item.setSpanishPassagesCount(stim.getTranslations().getEsp().getPassages().size());
        } else {
            item.setEnglishPassagesCount(0);
            item.setSpanishPassagesCount(0);
        }
    }

    private Set<ContentUpdateNeed> getContentUpdatedNeed(final BaseItem item, final Item iatItem, final String author) {
        if (iatItem.getCore() == null) {
            return new HashSet<>();
        }

        return iatItem.getCore().getContentUpdateNeeds().stream()
                .map(contentUpdateNeed -> {
                    ContentUpdateNeed need = new ContentUpdateNeed();
                    need.setUpdatedBy(author);
                    need.setContentUpdateNeedCreateDate(mapNullablDate(contentUpdateNeed.getCreateDate()));
                    need.setItem(item);
                    need.setInternalResolution(defaultString(contentUpdateNeed.getInternalResolution()));
                    need.setInternalResolutionDate(mapNullablDate(contentUpdateNeed.getInternalResolutionDate()));
                    need.setNotes(contentUpdateNeed.getNotes());
                    need.setResolution(contentUpdateNeed.getResolution());
                    need.setResolutionDate(mapNullablDate(contentUpdateNeed.getResolutionDate()));
                    return need;
                }).collect(Collectors.toSet());
    }

    private static Instant mapNullablDate(Date date) {
        return date == null ? null : date.toInstant();
    }

    private static class ItemInformation {
        final Item item;
        final ItemMetadata itemMetadata;
        final Integer stimulusId;

        ItemInformation(final Item item, final ItemMetadata itemMetadata, final Integer stimulusId) {
            this.item = item;
            this.itemMetadata = itemMetadata;
            this.stimulusId = stimulusId;
        }

        ItemInformation(final Item item, final ItemMetadata itemMetadata) {
            this(item, itemMetadata, null);
        }

        ItemInformation(final Item item) {
            this(item, null, null);
        }

        Item getItem() {
            return item;
        }

        Optional<ItemMetadata> getItemMetadata() {
            return Optional.ofNullable(itemMetadata);
        }

        Optional<Integer> getStimulusId() {
            return Optional.ofNullable(stimulusId);
        }
    }

    private static class Attachments {
        Set<Attachment> attachments;
        Instant mostRecentUploadDate;

        Attachments(final Set<Attachment> attachments, final Instant mostRecentUploadDate) {
            this.attachments = attachments;
            this.mostRecentUploadDate = mostRecentUploadDate;
        }

        Set<Attachment> getAttachments() {
            return attachments;
        }

        Optional<Instant> getMostRecentUploadDate() {
            return Optional.ofNullable(mostRecentUploadDate);
        }
    }
}
