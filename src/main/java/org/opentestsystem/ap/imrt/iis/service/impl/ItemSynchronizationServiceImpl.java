package org.opentestsystem.ap.imrt.iis.service.impl;

import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.rest.item.ItemCommitResponse;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.imrt.iis.client.ItemEventListener;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemSynchronizationResponse;
import org.opentestsystem.ap.imrt.iis.model.ItemUpdateEvent;
import org.opentestsystem.ap.imrt.iis.service.ItemDeleteNotificationHandler;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.opentestsystem.ap.imrt.iis.service.ItemSynchronizationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Service
public class ItemSynchronizationServiceImpl implements ItemSynchronizationService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemSynchronizationServiceImpl.class);
    private final ItemEventListener itemEventListener;
    private final ItemDeleteNotificationHandler itemDeleteNotificationHandler;
    private final OperationalEventService logger;
    private final ItemBankProperties itemBankProperties;
    private final BaseItemRepository baseItemRepository;
    private final ItemService itemService;

    @Autowired
    public ItemSynchronizationServiceImpl(final ItemEventListener itemEventListener,
                                          final ItemDeleteNotificationHandler itemDeleteNotificationHandler,
                                          final OperationalEventService logger,
                                          final ItemBankProperties itemBankProperties,
                                          final BaseItemRepository baseItemRepository,
                                          final ItemService itemService) {
        this.itemEventListener = itemEventListener;
        this.itemDeleteNotificationHandler = itemDeleteNotificationHandler;
        this.logger = logger;
        this.itemBankProperties = itemBankProperties;
        this.baseItemRepository = baseItemRepository;
        this.itemService = itemService;
    }

    @Override
    public ItemSynchronizationResponse synchronize() {
        final Instant syncJobStartTime = Instant.now();

        logger.info(LOG, "Sync-Item-Job: Syncing IMRT with itembank. \n project page size: {}\nexisting projects page size: {}\n,Item Deleted Sync Disabled: {}",
                itemBankProperties.getGroup(), itemBankProperties.getProjectsPerPage(), itemBankProperties.getDeleteItemGitPageSize(), itemBankProperties.isDeleteSyncDisabled());

        int itemsRemovedFromImrt = 0;
        if (!itemBankProperties.isDeleteSyncDisabled()) {
            logger.info(LOG, "Sync-Item-Job: Removing IMRT projects no longer in item bank");
            itemsRemovedFromImrt = removeProjectsNoLongerInSourceControl();
        } else {
            logger.info(LOG, "Sync-Item-Job: Process to check for deleted items in the itembank is disabled");
        }

        logger.info(LOG, "Sync-Item-Job: Syncing projects in item bank with IMRT");
        final Instant syncProjectStartTime = Instant.now();

        int totalItemsSynced = 0;
        int numberOfItemsWithoutWebhook = 0;

        List<Integer> activeItemIds = getItemIdsToSync();
        logger.info(LOG, "Syncing {} items in the item bank", activeItemIds.size());
        for (Integer itemId : activeItemIds) {
            logger.info(LOG, "Syncing item {}", itemId);
            updateItem(itemId);
            totalItemsSynced++;
            logger.info(LOG, "Processed {} out of {} items in the itembank", totalItemsSynced, activeItemIds.size());
        }

        logger.info(LOG, "Sync-Item-Job: Synced {} projects. Process time: {} seconds", totalItemsSynced, Duration.between(syncProjectStartTime, Instant.now()).getSeconds());
        logger.info(LOG, "Sync-Item-Job: Sync Job Complete. Total Job time: {} seconds", Duration.between(syncJobStartTime, Instant.now()).getSeconds());

        return new ItemSynchronizationResponse(numberOfItemsWithoutWebhook,
                totalItemsSynced,
                itemsRemovedFromImrt);
    }

    private int removeProjectsNoLongerInSourceControl() {
        final Instant removeProjectStartTime = Instant.now();

        PageRequest pageRequest = new PageRequest(0, itemBankProperties.getDeleteItemGitPageSize());
        Page<BaseItem> page = baseItemRepository.findAll(pageRequest);
        final int totalPages = page.getTotalPages();

        Collection<Integer> idsToRemove = new HashSet<>(findProjectsToRemove(page));
        logger.info(LOG, "Sync-Item-Job: Items not in Itembank Process: Processed {} page out of total pages {}", 0, totalPages);

        for (int i = 1; i < totalPages; i++) {
            PageRequest request = new PageRequest(i, itemBankProperties.getDeleteItemGitPageSize());
            page = baseItemRepository.findAll(request);
            idsToRemove.addAll(findProjectsToRemove(page));

            logger.info(LOG, "Sync-Item-Job: Items not in Itembank Process: Processed {} page out of total pages {}", i, totalPages);
        }

        if (!idsToRemove.isEmpty()) {
            for (final Integer itemId : idsToRemove) {
                itemDeleteNotificationHandler.processItemMessage(itemId);
            }
        }

        logger.info(LOG, "Sync-Item-Job: Removed {} projects that are no longer in the itembank. Process time: {} seconds", idsToRemove.size(), Duration.between(removeProjectStartTime, Instant.now()).getSeconds());

        return idsToRemove.size();
    }

    private List<Integer> getItemIdsToSync() {
        return itemService.getItemIdsInItemBank().stream().map(s -> {
            try {
                return Integer.parseInt(s);
            } catch (NumberFormatException nfe) {
                return Integer.MIN_VALUE;
            }
        }).filter(integer -> Integer.MIN_VALUE != integer).sorted().collect(Collectors.toList());
    }

    private Collection<Integer> findProjectsToRemove(Page<BaseItem> page) {
        Collection<Integer> idsToRemove = new HashSet<>();
        for (BaseItem baseItem : page) {
            Optional<ItemEntityResponse> maybeEntityResponse = itemService.findLatestItemEntityByItemId(baseItem.getId());
            if (!maybeEntityResponse.isPresent()) {
                idsToRemove.add(baseItem.getId());
            }
        }

        return idsToRemove;
    }

    @Override
    public void synchronizeItem(final int itemId) {
        if (itemBankProperties.getItemsToIgnore().contains(itemId)) {
            logger.info(LOG, "Ingest is configured to ignore item {}", itemId);
            return;
        }

        updateItem(itemId);
    }

    private void updateItem(final int itemId) {
        if (itemBankProperties.getItemsToIgnore().contains(itemId)) {
            logger.info(LOG, "Ingest is configured to ignore item {}", itemId);
            return;
        }

        BaseItem baseItem = baseItemRepository.findById(itemId);
        ItemUpdateEvent event;

        if (baseItem != null && baseItem.getCommitId() != null) {
            event = new ItemUpdateEvent(itemId, baseItem.getCommitId());
        } else {
            ItemCommitResponse itemCommitResponse = itemService.findAllCommits(itemId).orElseThrow(() -> new RuntimeException("Could not find item commits from IMS fro item " + itemId));

            if (itemCommitResponse.getCommits().isEmpty()) {
                itemDeleteNotificationHandler.processItemMessage(itemId);
                return;
            }

            event = new ItemUpdateEvent(itemId, itemCommitResponse.getCommits().get(0));
        }

        itemEventListener.onUpdateItem(event);
    }
}
