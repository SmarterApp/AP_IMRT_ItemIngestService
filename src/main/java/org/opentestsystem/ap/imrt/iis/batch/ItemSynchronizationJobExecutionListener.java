package org.opentestsystem.ap.imrt.iis.batch;

import org.apache.commons.lang.exception.ExceptionUtils;
import org.opentestsystem.ap.imrt.iis.model.ItemSynchronizationResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

/**
 * A {@link org.springframework.batch.core.JobExecutionListener} that prevents the item synchronization job from running
 * more than one instance at a time.
 */
@Component
public class ItemSynchronizationJobExecutionListener implements JobExecutionListener {
    // The active job execution, which will act as a lock.
    private JobExecution activeJob;
    private static final Logger logger = LoggerFactory.getLogger(ItemSynchronizationJobExecutionListener.class);

    @Override
    public void beforeJob(final JobExecution jobExecution) {
        // Create a lock to examine the active job.  If the active job is already running, prevent the execution of
        // the new job request.
        synchronized (jobExecution) {
            if (activeJob != null && activeJob.isRunning()) {
                logger.warn("An Item Synchronization Process with Job execution id: {} is already running.  Wait for this job to complete before starting another one.", activeJob.getId());
                jobExecution.stop();
            } else {
                activeJob = jobExecution;
                logger.info("Item Synchronization Process starting.  Job execution id: {}", activeJob.getId());
            }
        }
    }

    @Override
    public void afterJob(final JobExecution jobExecution) {
        // Release the lock and log completion
        synchronized (jobExecution) {
            if (jobExecution.equals(activeJob)) {
                final ItemSynchronizationResponse response =
                        (ItemSynchronizationResponse) jobExecution.getExecutionContext().get(ItemSynchronizationResponse.EXECUTION_CONTEXT_DATA_KEY);

                String exitStatusMessage;
                if (jobExecution.getAllFailureExceptions().isEmpty()) {
                    exitStatusMessage = String.format("Total item bank ids: %d, number of items requiring project webhook: %d",
                            response.getNumberOfItembankIds(),
                            response.getNumberOfItemsWithoutWebhook());
                } else {
                    final String[] exceptionMessages = jobExecution.getAllFailureExceptions().stream()
                            .map(throwable -> String.format("%s: %s", throwable.getMessage(), ExceptionUtils.getStackTrace(throwable)))
                            .toArray(String[]::new);
                    exitStatusMessage = String.join("\n", exceptionMessages);
                }

                jobExecution.setExitStatus(new ExitStatus(jobExecution.getExitStatus().getExitCode(), exitStatusMessage));

                logger.info("Item Synchronization Process complete.  Job execution id: {}, exit status code: {}, exit message: {}",
                        activeJob.getId(),
                        activeJob.getExitStatus().getExitCode(),
                        exitStatusMessage);

                activeJob = null;
            }
        }
    }
}
