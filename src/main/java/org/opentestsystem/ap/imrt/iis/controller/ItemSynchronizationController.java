package org.opentestsystem.ap.imrt.iis.controller;

import org.opentestsystem.ap.imrt.iis.batch.ItemSyncJobBuilderFactory;
import org.opentestsystem.ap.imrt.iis.model.ItemSyncJobStatus;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobParameters;
import org.springframework.batch.core.JobParametersInvalidException;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.launch.JobExecutionNotRunningException;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.launch.JobOperator;
import org.springframework.batch.core.launch.NoSuchJobException;
import org.springframework.batch.core.launch.NoSuchJobExecutionException;
import org.springframework.batch.core.repository.JobExecutionAlreadyRunningException;
import org.springframework.batch.core.repository.JobInstanceAlreadyCompleteException;
import org.springframework.batch.core.repository.JobRestartException;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("sync")
public class ItemSynchronizationController {
    private final JobLauncher jobLauncher;
    private final JobOperator jobOperator;
    private final ItemSyncJobBuilderFactory jobBuilderFactory;
    private final JobExplorer jobExplorer;

    public ItemSynchronizationController(JobLauncher jobLauncher, JobOperator jobOperator, ItemSyncJobBuilderFactory jobBuilderFactory, JobExplorer jobExplorer) {
        this.jobLauncher = jobLauncher;
        this.jobOperator = jobOperator;
        this.jobBuilderFactory = jobBuilderFactory;
        this.jobExplorer = jobExplorer;
    }

    @PostMapping("/start")
    @ResponseStatus(HttpStatus.CREATED)
    public ItemSyncJobStatus start() throws Exception {
        // TODO - creating the job takes a long time because it has to go out and get the list
        // of item Ids from the itembank. Might be a good idea to move this to a synchronized
        // method and return right away here so the request doesn't time out.
        Job job = jobBuilderFactory.buildItemSynchronizationJob();
        JobExecution execution = jobLauncher.run(job, new JobParameters());
        return new ItemSyncJobStatus(execution.getId(), execution.getStatus().name());
    }

    @PutMapping("stop/{jobId}")
    public ItemSyncJobStatus stop(@PathVariable("jobId") long jobId) throws NoSuchJobExecutionException,
            JobExecutionNotRunningException {
        jobOperator.stop(jobId);
        JobExecution execution = jobExplorer.getJobExecution(jobId);
        return new ItemSyncJobStatus(execution.getId(), execution.getStatus().name());
    }

    @GetMapping("status/{jobId}")
    public ItemSyncJobStatus status(@PathVariable("jobId") long jobId) {
        JobExecution execution = jobExplorer.getJobExecution(jobId);
        return new ItemSyncJobStatus(execution.getId(), execution.getStatus().name());
    }

    @PutMapping("restart/{jobId}")
    public ItemSyncJobStatus restart(@PathVariable("jobId") long jobId) throws NoSuchJobExecutionException,
            JobParametersInvalidException, JobRestartException, JobInstanceAlreadyCompleteException, NoSuchJobException {
        jobId = jobOperator.restart(jobId);
        JobExecution execution = jobExplorer.getJobExecution(jobId);
        return new ItemSyncJobStatus(execution.getId(), execution.getStatus().name());
    }

    @DeleteMapping("delete/{jobId}")
    public ItemSyncJobStatus delete(@PathVariable("jobId") long jobId) throws NoSuchJobExecutionException,
            JobExecutionAlreadyRunningException {
        JobExecution execution = jobOperator.abandon(jobId);
        return new ItemSyncJobStatus(execution.getId(), execution.getStatus().name());
    }
}
