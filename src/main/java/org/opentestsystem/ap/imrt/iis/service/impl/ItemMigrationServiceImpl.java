package org.opentestsystem.ap.imrt.iis.service.impl;

import org.apache.commons.collections4.IterableUtils;
import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.imrt.iis.client.ItemEventListener;
import org.opentestsystem.ap.imrt.iis.config.ItemIngestServiceProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemMigrationResponse;
import org.opentestsystem.ap.imrt.iis.model.ItemUpdateEvent;
import org.opentestsystem.ap.imrt.iis.service.ItemDeleteNotificationHandler;
import org.opentestsystem.ap.imrt.iis.service.ItemIngestService;
import org.opentestsystem.ap.imrt.iis.service.ItemMigrationService;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Optional;

@Service
public class ItemMigrationServiceImpl implements ItemMigrationService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemMigrationServiceImpl.class);
    private final ItemIngestService itemIngestService;
    private final ItemIngestServiceProperties itemIngestServiceProperties;
    private final OperationalEventService logger;
    private final BaseItemRepository baseItemRepository;
    private final ItemService itemService;
    private final ItemDeleteNotificationHandler itemDeleteNotificationHandler;
    private final ItemEventListener itemEventListener;

    public ItemMigrationServiceImpl(final ItemIngestService itemIngestService,
                                    final ItemIngestServiceProperties itemIngestServiceProperties,
                                    final OperationalEventService logger, final BaseItemRepository baseItemRepository, final ItemService itemService, final ItemDeleteNotificationHandler itemDeleteNotificationHandler, final ItemEventListener itemEventListener) {
        this.itemIngestService = itemIngestService;
        this.itemIngestServiceProperties = itemIngestServiceProperties;
        this.logger = logger;
        this.baseItemRepository = baseItemRepository;
        this.itemService = itemService;
        this.itemDeleteNotificationHandler = itemDeleteNotificationHandler;
        this.itemEventListener = itemEventListener;
    }

    @Override
    public ItemMigrationResponse migrateAllExistingItems() {
        Pageable pageRequest = new PageRequest(0, itemIngestServiceProperties.getImrtPageQueryLimit());
        Page<BaseItem> baseItemPage;
        int numberOfItemBankIds = 0;
        int numberOfErrors = 0;

        do {
            Instant start = Instant.now();
            baseItemPage = baseItemRepository.findAll(pageRequest);

            logger.info(LOG, "Getting the first page took {} milliseconds", Duration.between(start, Instant.now()).toMillis());

            final List<BaseItem> baseItems =
                    IterableUtils.toList(baseItemPage.getContent());
            for (final BaseItem baseItem : baseItems) {
                final int itemId = baseItem.getId();

                try {
                    itemEventListener.onMigrateItem(itemId);
                    numberOfItemBankIds++;
                } catch (final Exception e) {
                    // In this case, we want to continue processing items even if an exception is encountered.
                    // Instead of throwing, the exception will be logged and the migration process will continue.
                    logger.error(LOG,
                            e,
                            "Unexpected error attempting to migrate item {}",
                            itemId);

                    numberOfErrors++;
                }
            }

            pageRequest = baseItemPage.nextPageable();
        } while (baseItemPage.hasNext());

        return new ItemMigrationResponse(numberOfItemBankIds, numberOfErrors);
    }

    @Override
    public ItemMigrationResponse migrateItem(final int itemId) {
        BaseItem item = baseItemRepository.findById(itemId);
        Optional<ItemUpdateEvent> maybeItemUpdateEvent = getItemUpdateEvent(item);

        if (!maybeItemUpdateEvent.isPresent()) {
            return new ItemMigrationResponse(0, 0);
        }

        boolean migrated = itemIngestService.syncItemWithLatestRevision(maybeItemUpdateEvent.get());

        if (!migrated) {
            itemDeleteNotificationHandler.processItemMessage(itemId);
            return new ItemMigrationResponse(0, 0);
        }

        return new ItemMigrationResponse(1, 0);
    }

    private Optional<ItemUpdateEvent> getItemUpdateEvent(BaseItem item) {
        if (item == null) {
            return Optional.empty();
        }

        if(item.getCommitId() != null) {
            return Optional.of(new ItemUpdateEvent(item.getId(), item.getCommitId(), item.getUpdatedBy()));
        }

        Optional<ItemEntityResponse> itemEntityResponse = itemService.findLatestItemEntityByItemId(item.getId());

        if(!itemEntityResponse.isPresent()) {
            logger.warn(LOG, null, "Item {} could not be found in the TIMS data store", item.getId());
            return Optional.empty();
        }

        return Optional.of(new ItemUpdateEvent(item.getId(), itemEntityResponse.get().getId(), item.getUpdatedBy()));
    }
}
