package org.opentestsystem.ap.imrt.iis.service.impl;

import org.apache.commons.collections4.IterableUtils;
import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.imrt.iis.config.ItemIngestServiceProperties;
import org.opentestsystem.ap.imrt.iis.model.ItemMigrationResponse;
import org.opentestsystem.ap.imrt.iis.model.ItemUpdateEvent;
import org.opentestsystem.ap.imrt.iis.service.ItemIngestService;
import org.opentestsystem.ap.imrt.iis.service.ItemMigrationService;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class ItemMigrationServiceImpl implements ItemMigrationService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemMigrationServiceImpl.class);
    private final ItemIngestService itemIngestService;
    private final ItemIngestServiceProperties itemIngestServiceProperties;
    private final OperationalEventService logger;
    private final BaseItemRepository baseItemRepository;
    private final ItemService itemService;

    public ItemMigrationServiceImpl(final ItemIngestService itemIngestService,
                                    final ItemIngestServiceProperties itemIngestServiceProperties,
                                    final OperationalEventService logger, final BaseItemRepository baseItemRepository, final ItemService itemService) {
        this.itemIngestService = itemIngestService;
        this.itemIngestServiceProperties = itemIngestServiceProperties;
        this.logger = logger;
        this.baseItemRepository = baseItemRepository;
        this.itemService = itemService;
    }

    @Override
    public ItemMigrationResponse migrateAllExistingItems() {
        Pageable pageRequest = new PageRequest(0, itemIngestServiceProperties.getImrtPageQueryLimit());
        Page<BaseItem> baseItemPage;
        int numberOfItemBankIds = 0;
        int numberOfErrors = 0;

        do {
            baseItemPage = baseItemRepository.findAll(pageRequest);

            final List<BaseItem> baseItems =
                    IterableUtils.toList(baseItemPage.getContent());
            for (final BaseItem baseItem : baseItems) {
                final int itemId = baseItem.getId();

                try {
                    Optional<ItemUpdateEvent> maybeItemUpdateEvent = getItemUpdateEvent(baseItem);

                    if(!maybeItemUpdateEvent.isPresent()) {
                        logger.warn(LOG, null, "Failed to find TIMS item for {}", baseItem.getId());
                        numberOfErrors++;
                        continue;
                    }

                    ItemUpdateEvent itemUpdateEvent = maybeItemUpdateEvent.get();

                    boolean synced = itemIngestService.syncItemWithLatestRevision(itemUpdateEvent);

                    if (synced) {
                        logger.info(LOG, "Migrated item id {} to commit hash {}", itemId, itemUpdateEvent.getCommitId());
                        numberOfItemBankIds++;
                    } else {
                        logger.warn(LOG, null, "Could not migrate item {} because it does not have an item", itemId);
                    }
                } catch (final Exception e) {
                    // In this case, we want to continue processing items even if an exception is encountered.
                    // Instead of throwing, the exception will be logged and the migration process will continue.
                    logger.error(LOG,
                            e,
                            "Unexpected error attempting to migrate item {}",
                            itemId);

                    numberOfErrors++;
                }
            }

            pageRequest = baseItemPage.nextPageable();
        } while (baseItemPage.hasNext());

        return new ItemMigrationResponse(numberOfItemBankIds, numberOfErrors);
    }

    @Override
    public ItemMigrationResponse migrateItem(final int itemId) {
        BaseItem item = baseItemRepository.findById(itemId);
        Optional<ItemUpdateEvent> maybeItemUpdateEvent = getItemUpdateEvent(item);

        if (!maybeItemUpdateEvent.isPresent()) {
            return new ItemMigrationResponse(0, 0);
        }

        boolean migrated = itemIngestService.syncItemWithLatestRevision(maybeItemUpdateEvent.get());

        if (!migrated) {
            return new ItemMigrationResponse(0, 0);
        }

        return new ItemMigrationResponse(1, 0);
    }

    private Optional<ItemUpdateEvent> getItemUpdateEvent(BaseItem item) {
        if (item == null) {
            return Optional.empty();
        }

        if(item.getCommitId() != null) {
            return Optional.of(new ItemUpdateEvent(item.getId(), item.getCommitId()));
        }

        Optional<ItemEntityResponse> itemEntityResponse = itemService.findLatestItemEntityByItemId(item.getId());

        if(!itemEntityResponse.isPresent()) {
            logger.warn(LOG, null, "Item {} could not be found in the TIMS data store", item.getId());
            return Optional.empty();
        }

        return Optional.of(new ItemUpdateEvent(item.getId(), itemEntityResponse.get().getId()));
    }
}
