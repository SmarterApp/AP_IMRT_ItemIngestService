package org.opentestsystem.ap.imrt.iis.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;

/**
 * Implementation of the ProjectLockService interface to provide jdbc based simple time expiring locking for projects.
 * A project is considered locked  * if a row exists in the project_lock database table for the projectId, and the
 * lock_time in that row is not far enough in the past to be considered expired. The epoch representation of
 * the lock_time is used as a unique identifier for the lock. A project is considered unlocked
 * if no row exists in the project_lock database table for the projectId, or if the row exists
 * but the lock_time has an epoch time value of zero.
 */
@Service
public class ProjectLockServiceJdbcImpl implements ProjectLockService {
    private static final Logger logger = LoggerFactory.getLogger(ProjectLockServiceJdbcImpl.class);

    private final JdbcTemplate jdbcTemplate;
    private final OperationalEventService operationalEventService;

    // Maximum length of time a lock can be held.
    @Value("${iis.maxProjectLockSeconds:60}")
    private Integer maxProjectLockSeconds;

    // SQL query to find the lock_time for a project
    private static final String GET_LOCKTIME_SQL = "select lock_time from project_lock where project_id = ?";

    // SQL query to create a lock entry.
    private static final String INSERT_SQL = "insert into project_lock(project_id, lock_time, created_at, updated_at, updated_by) values (?, ?, ?, ?, 'internal')";

    // SQL query to update an existing lock. This will "acquire" the lock by setting the lock time
    private static final String UPDATE_SQL = "update project_lock set lock_time = ?, updated_at = ? where project_id = ? and lock_time = ?";


    public ProjectLockServiceJdbcImpl(JdbcTemplate jdbcTemplate, OperationalEventService operationalEventService) {
        this.jdbcTemplate = jdbcTemplate;
        this.operationalEventService = operationalEventService;
    }

    @Transactional
    @Override
    public Long lockProject(int projectId) {
        Date now = new Date();

        // Check to see if it is already locked
        try {
            // This will throw an exception if the row does not exist in the DB
            Date existingLock = jdbcTemplate.queryForObject(GET_LOCKTIME_SQL, new Object[]{projectId}, Date.class);
            // The lock exists, see if it has expired
            if (now.getTime() - existingLock.getTime() > maxProjectLockSeconds * 1000) {
                logger.debug("Trying to lock project {}. There is an existing expired lock {}", projectId, existingLock);
                // Lock expired, go ahead and take it. Generally this will be happen because the project
                // has been unlocked, and the time has been set to zero
                if (existingLock.getTime() != 0) {
                    operationalEventService.serviceWarning(logger, null, "Existing project lock has expired for projectId {} lock time {}", projectId, existingLock);
                }
                int rows = jdbcTemplate.update(UPDATE_SQL, new Object[]{now, now, projectId, existingLock});
                if (1 != rows) {
                    operationalEventService.serviceError(logger, null,"Unable to update project_lock entry for projectId {}", projectId);
                    return null;
                }
                return now.getTime();
            } else {
                logger.debug("ProjectId {} is already locked", projectId);
                return null;
            }
        } catch (Exception e) {
            // The entry does not exist, create it and return the lock time
            logger.debug("First time creating lock for project {} lock_time {}", projectId, now);
            // If someone else got in since we checked, and inserted a row here, this will throw
            // an exception because of the duplicate key
            try {
                int rows = jdbcTemplate.update(INSERT_SQL, new Object[]{projectId, now, now, now});
                if (1 != rows) {
                    operationalEventService.serviceError(logger, null, "Unable to create project_lock entry for projectId {}", projectId);
                    return null;
                }
                return now.getTime();
            } catch (Exception ex) {
                return null;
            }
        }
    }

    @Override
    public void unlockProject(int projectId, long lockId) {
        Date now = new Date();

        // Update the row in the database to set the lock_time back to zero, but only if the existing lock_time
        // matches the supplied lock value
        int rows = jdbcTemplate.update(UPDATE_SQL, new Object[]{new Date(0), now, projectId, new Date(lockId)});
        if (1 != rows) {
            operationalEventService.serviceError(logger, null,"Unable to unlock project for projectId {} lock {}", projectId, lockId);
        } else {
            logger.debug("Unlocked projectId {}", projectId);
        }
    }
}
