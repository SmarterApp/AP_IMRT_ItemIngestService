package org.opentestsystem.ap.imrt.iis.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Date;
import java.util.Optional;

/**
 * Implementation of the ProjectLockService interface to provide jdbc based simple time expiring locking for projects.
 * A project is considered locked  if a row exists in the project_lock database table for the projectId, and the
 * locked_at in that row is not far enough in the past to be considered expired. The epoch representation of
 * the lock_time is used as a unique identifier for the lock. A project is considered unlocked
 * if no row exists in the project_lock database table for the projectId.
 */
@Service
public class ProjectLockServiceJdbcImpl implements ProjectLockService {
    private static final Logger logger = LoggerFactory.getLogger(ProjectLockServiceJdbcImpl.class);

    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    private final OperationalEventService operationalEventService;

    // Maximum length of time a lock can be held.
    @Value("${iis.maxProjectLockSeconds:60}")
    private Integer maxProjectLockSeconds;

    // SQL query to acquire a lock
    private static final String ACQUIRE_LOCK_SQL = "INSERT INTO project_lock(project_id, locked_at, created_at, updated_at, updated_by) " +
            "VALUES (:projectId, :now, :now, :now, 'internal') ON CONFLICT(project_id) DO UPDATE SET locked_at = :now, updated_at = :now " +
            "WHERE (SELECT locked_at FROM project_lock WHERE project_id = :projectId) + INTERVAL '60 seconds' < :now";

    // SQL query to delete a lock
    private static final String DELETE_LOCK_SQL = "DELETE FROM project_lock WHERE project_id = :projectId AND locked_at = :lockTime";

    public ProjectLockServiceJdbcImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate, OperationalEventService operationalEventService) {
        this.namedParameterJdbcTemplate = namedParameterJdbcTemplate;
        this.operationalEventService = operationalEventService;
    }

    @Override
    public Optional<Long> lockProject(int projectId) {
        Date now = new Date();

        SqlParameterSource namedParameters = new MapSqlParameterSource()
                .addValue("projectId", projectId)
                .addValue("now", now)
                .addValue("maxLockSeconds", maxProjectLockSeconds);
        int rows = namedParameterJdbcTemplate.update(ACQUIRE_LOCK_SQL, namedParameters);
        if (rows == 1) {
            // We got the lock
            logger.debug("Acquired lock projectId {} lockId {}", projectId, now.getTime());
            return Optional.of(now.getTime());
        } else {
            // Someone else is holding it
            logger.debug("ProjectId {} is already locked", projectId);
            return Optional.empty();
        }

    }

    @Override
    public void unlockProject(int projectId, long lockId) {

        SqlParameterSource namedParameters = new MapSqlParameterSource()
                .addValue("projectId", projectId)
                .addValue("lockTime", new Date(lockId));
        int rows = namedParameterJdbcTemplate.update(DELETE_LOCK_SQL, namedParameters);

        if (1 != rows) {
            // This will happen if we have held the lock for too long.
            operationalEventService.serviceError(logger, null,"Unable to unlock project for projectId {} lock {}", projectId, lockId);
        } else {
            logger.debug("Unlocked projectId {} lockId {}", projectId, lockId);
        }
    }
}
