package org.opentestsystem.ap.imrt.iis.service;

import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevisionImpl;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.List;
import java.util.Optional;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 * <p>
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
@ConditionalOnProperty(value = "test.enabled", havingValue = "false", matchIfMissing = true)
public class ItemUpdateNotificationHandler {
    private static final Logger logger = LoggerFactory.getLogger(ItemUpdateNotificationHandler.class);

    private final ProjectLockService projectLockService;
    private final ItemBankClient itemBankClient;
    private final ItemRevisionWriter itemRevisionWriter;
    private final ItemGitInformationRepository itemGitInformationRepository;
    private final OperationalEventService operationalEventService;

    public ItemUpdateNotificationHandler(ProjectLockService projectLockService, ItemBankClient itemBankClient,
                                         ItemRevisionWriter itemRevisionWriter, ItemGitInformationRepository itemGitInformationRepository,
                                         OperationalEventService operationalEventService) {
        this.projectLockService = projectLockService;
        this.itemBankClient = itemBankClient;
        this.itemRevisionWriter = itemRevisionWriter;
        this.itemGitInformationRepository = itemGitInformationRepository;
        this.operationalEventService = operationalEventService;
    }

    /**
     * This method is invoked to process messages on the item-update queue.
     * If the method returns normally, the message will be acked. If the method
     * throws an exception, the message will be requeued for later processing.
     *
     * @param itemId Unique item bank id for the item that has been updated.
     */
    @RabbitListener(queues = "item-update")
    public void updateItem(Integer itemId) {
        logger.debug("Received item update message for id {}", itemId);

        Optional<Long> lock = Optional.empty();

        // Lock the project first. Make sure we always unlock it in the finally clause
        try {
            lock = projectLockService.lockProject(itemId);
            if (!lock.isPresent()) {
                logger.debug("Project {} is already locked. Requeue message for later", itemId);
                throw new RuntimeException("Project is locked, requeue message");
            }
            // We got the lock, so process the update
            syncItemToItemBank(itemId);
        } finally {
            lock.ifPresent(aLong -> projectLockService.unlockProject(itemId, aLong));
        }
    }

    /**
     * Synchronize an item to the item bank, by ingesting any revisions we have not
     * already processed.
     *
     * @param itemId Unique git id for the item to be processed.
     */
    private void syncItemToItemBank(int itemId) {
        try {
            // See if we have any existing itemGitInformation for this item in the database
            ItemGitInformation existingGitInfo = itemGitInformationRepository.findOne(itemId);
            logger.debug("ExistingGitInfo {} commitId {} date {}", existingGitInfo,
                    existingGitInfo != null ? existingGitInfo.getCurrentCommitHash() : null,
                    existingGitInfo != null ? existingGitInfo.getCurrentCommitDate() : null);

            // Get the history of the item since we last processed it
            List<ItemBankItemRevision> itemHistoryList = getItemHistorySinceLastProcessed(itemId, existingGitInfo);

            // Sync each change
            for (ItemBankItemRevision revision : itemHistoryList) {
                existingGitInfo = syncItemRevision(existingGitInfo, revision);
            }
        } catch (RuntimeException ex) {
            /*
             * Most exceptions that occur, such as errors parsing the json data coming from the item bank,
             * or unexpected content in the item, result in an exception, which results in a loop where we
             * throw, reque the message, only to have the same error occur again and again, hitting GitLab
             * and spewing into the logs. For now, let's catch them all until things are a bit more stable,
             * and then see if we want to isolate a few we might want to let bubble up for a message requeue.
             * Anything we miss here will be retried by the sync job as well.
             */
            operationalEventService.serviceError(logger, ex, "Unexpected exception while processing item {}", itemId);
        }
    }

    /**
     * Synchronize a single revision of an item
     * @param existingGitInfo the previous item that was synchronized. May be null
     * @param itemBankItemRevision the itemBankItemRevision details for the revision
     * @return the ItemGitInformation object for the item revision that was synchronized
     */
    private ItemGitInformation syncItemRevision(ItemGitInformation existingGitInfo, ItemBankItemRevision itemBankItemRevision) {
        logger.debug("Synchronizing revision: date {} id {} name {}", itemBankItemRevision.getRevisionDate(), itemBankItemRevision.getRevisionId(),
                itemBankItemRevision.getAuthor());

        // Create an ItemRevision
        ItemRevision revision = new ItemRevisionImpl(itemBankItemRevision, existingGitInfo);

        // TODO add a busness logic processor to allow various operations based on comparing
        // the old and the new item before we save it

        // Save to the DB
        itemRevisionWriter.saveItemRevision(revision);

        // Generate operational event for the item create/update
        generateItemEvent(existingGitInfo, revision);

        // Update our existing info to what we just saved
        existingGitInfo = revision.getItemGitInformation();
        return existingGitInfo;
    }

    /**
     * Generate an itemCreated or an itemUpdate event
     * @param existingGitInfo used to determine if this is a create or an update
     * @param revision ItemRevision that was created or updated
     */
    private void generateItemEvent(ItemGitInformation existingGitInfo, ItemRevision revision) {
        if (null == existingGitInfo) {
            operationalEventService.itemCreatedEvent(logger, revision.getImrtItem().getKey(),
                    revision.getImrtItem().getId(), revision.getItemGitInformation().getProjectId());
        } else {
            operationalEventService.itemUpdatedEvent(logger, revision.getImrtItem().getKey(),
                    revision.getImrtItem().getId(), revision.getItemGitInformation().getProjectId());
        }
    }

    /**
     * Get the history of an item from the itembank
     *
     * @param itemId          itemId of the item
     * @param existingGitInfo information about the last commit we processed for this item. May be null
     * @return an historical list of revisions for the item that have occurred since the last revision processed,
     * or since the dawn of time if existingGitInfo is null.
     */
    private List<ItemBankItemRevision> getItemHistorySinceLastProcessed(int itemId, ItemGitInformation existingGitInfo) {
        // Get the history of the item from the item bank, going back to the last update
        // we processed, or the dawn of time if existingGitInfo is null
        List<ItemBankItemRevision> itemHistoryList = itemBankClient.getItemHistory(itemId,
                existingGitInfo != null ? existingGitInfo.getCurrentCommitDate() : Instant.ofEpochSecond(0));

        logger.debug("Total commits {}", itemHistoryList.size());
        // Generally the first item returned is the last one we processed. We could increase the since
        // time, but the granularity is seconds, and we want to be very sure we never miss a commit
        // so instead we will remove the first item from the list if we have already processed it
        if (itemHistoryList.size() > 0 && existingGitInfo != null) {
            if (itemHistoryList.get(0).getRevisionId().equals(existingGitInfo.getCurrentCommitHash())) {
                itemHistoryList.remove(0);
                logger.debug("Removing first commit {} from the list as we have already processed it.",
                        existingGitInfo.getCurrentCommitHash());
            }
        }
        return itemHistoryList;
    }

}
