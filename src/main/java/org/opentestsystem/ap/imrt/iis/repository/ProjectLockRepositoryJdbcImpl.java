package org.opentestsystem.ap.imrt.iis.repository;

import org.opentestsystem.ap.imrt.iis.exception.ProjectLockException;
import org.opentestsystem.ap.imrt.iis.exception.ProjectUnlockException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;

import java.util.Date;

/**
 * Implementation of the ProjectLockRepository interface to provide jdbc based simple time expiring locking for projects.
 * A project is considered locked  if a row exists in the project_lock database table for the projectId, and the
 * locked_at in that row is not far enough in the past to be considered expired. The epoch representation of
 * the lock_time is used as a unique identifier for the lock. A project is considered unlocked
 * if no row exists in the project_lock database table for the projectId.
 */
@Repository
public class ProjectLockRepositoryJdbcImpl implements ProjectLockRepository {
    private static final Logger logger = LoggerFactory.getLogger(ProjectLockRepositoryJdbcImpl.class);

    private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

    // Maximum length of time a lock can be held.
    @Value("${iis.maxProjectLockSeconds:60}")
    private Integer maxProjectLockSeconds;

    // SQL query to acquire a lock
    private static final String ACQUIRE_LOCK_SQL = "INSERT INTO project_lock(project_id, locked_at, created_at, updated_at, updated_by) " +
            "VALUES (:projectId, :now, :now, :now, 'internal') ON CONFLICT(project_id) DO UPDATE SET locked_at = :now, updated_at = :now " +
            "WHERE (SELECT locked_at FROM project_lock WHERE project_id = :projectId) + INTERVAL '60 seconds' < :now";

    // SQL query to delete a lock
    private static final String DELETE_LOCK_SQL = "DELETE FROM project_lock WHERE project_id = :projectId AND locked_at = :lockTime";

    public ProjectLockRepositoryJdbcImpl(NamedParameterJdbcTemplate namedParameterJdbcTemplate) {
        this.namedParameterJdbcTemplate = namedParameterJdbcTemplate;
    }

    @Override
    public long acquireLock(int projectId) {
        Date now = new Date();

        SqlParameterSource namedParameters = new MapSqlParameterSource()
                .addValue("projectId", projectId)
                .addValue("now", now)
                .addValue("maxLockSeconds", maxProjectLockSeconds);
        if (1 == namedParameterJdbcTemplate.update(ACQUIRE_LOCK_SQL, namedParameters)) {
            // We got the lock
            logger.debug("Acquired lock projectId {} lockId {}", projectId, now.getTime());
            return now.getTime();
        }
        // Someone else is holding it
        logger.debug("ProjectId {} is already locked", projectId);
        throw new ProjectLockException("Project %d is already locked", projectId);
    }

    @Override
    public void releaseLock(int projectId, long lockId) {

        SqlParameterSource namedParameters = new MapSqlParameterSource()
                .addValue("projectId", projectId)
                .addValue("lockTime", new Date(lockId));
        if (1 != namedParameterJdbcTemplate.update(DELETE_LOCK_SQL, namedParameters)) {
            // This will happen if we have held the lock for too long.
            throw new ProjectUnlockException("Unable to unlock project for projectId %d lock %d", projectId, lockId);
        } else {
            logger.debug("Unlocked projectId {} lockId {}", projectId, lockId);
        }
    }
}
