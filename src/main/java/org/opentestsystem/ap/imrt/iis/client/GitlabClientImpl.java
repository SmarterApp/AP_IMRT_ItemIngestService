package org.opentestsystem.ap.imrt.iis.client;

import com.google.common.collect.Lists;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.Pager;
import org.gitlab4j.api.models.Branch;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.ProjectHook;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.GroupMemberSystemHookEvent;
import org.gitlab4j.api.systemhooks.GroupSystemHookEvent;
import org.gitlab4j.api.systemhooks.KeySystemHookEvent;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.systemhooks.PushSystemHookEvent;
import org.gitlab4j.api.systemhooks.RepositorySystemHookEvent;
import org.gitlab4j.api.systemhooks.SystemHookListener;
import org.gitlab4j.api.systemhooks.SystemHookManager;
import org.gitlab4j.api.systemhooks.TagPushSystemHookEvent;
import org.gitlab4j.api.systemhooks.TeamMemberSystemHookEvent;
import org.gitlab4j.api.systemhooks.UserSystemHookEvent;
import org.gitlab4j.api.webhook.BuildEvent;
import org.gitlab4j.api.webhook.IssueEvent;
import org.gitlab4j.api.webhook.MergeRequestEvent;
import org.gitlab4j.api.webhook.NoteEvent;
import org.gitlab4j.api.webhook.PipelineEvent;
import org.gitlab4j.api.webhook.PushEvent;
import org.gitlab4j.api.webhook.TagPushEvent;
import org.gitlab4j.api.webhook.WebHookListener;
import org.gitlab4j.api.webhook.WebHookManager;
import org.gitlab4j.api.webhook.WikiPageEvent;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.exception.GitLabApiRuntimeException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.repository.GitLabRepository;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Wrapper around the gitlab4j java web client:
 * https://github.com/gmessner/gitlab4j-api
 */
@Component
@ConditionalOnProperty(value = "test.enabled", havingValue = "false", matchIfMissing = true)
public class GitlabClientImpl implements SystemHookListener, WebHookListener, ItemBankClient, GitlabHookClient {
    private static final Logger logger = LoggerFactory.getLogger(GitlabClientImpl.class);
    private static final String MASTER_BRANCH_NAME = "master";
    private static final String CREATE_BRANCH_PREFIX = "create_";
    private static final String PROJECT_CREATE_EVENT = "CreateProjectSystemHookEvent";
    private static final String PROJECT_DESTROY_EVENT = "DestroyProjectSystemHookEvent";
    private static final String ITEM_FILE_NAME = "item.json";
    private static final int MAX_ITEMS_PER_PAGE = 100;

    private final ItemBankProperties gitlabProperties;
    private Namespace group;
    private final SystemHookManager systemHookManager = new SystemHookManager();
    private final WebHookManager webHookManager = new WebHookManager();
    private ItemEventListener projectListener;
    private final OperationalEventService operationalEventService;
    private final ItemParser itemParser;
    private final GitLabRepository gitLabRepository;


    @Autowired
    public GitlabClientImpl(ItemBankProperties gitlabProperties, OperationalEventService operationalEventService,
                            ItemParser itemParser, GitLabRepository gitLabRepository) {
        this.gitlabProperties = gitlabProperties;
        this.operationalEventService = operationalEventService;
        this.itemParser = itemParser;
        this.gitLabRepository = gitLabRepository;
    }

    @PostConstruct
    public void init() {
        final List<Namespace> namespaces = gitLabRepository.findAllNamespaces(gitlabProperties.getGroup());

        if (namespaces.isEmpty()) {
            throw new IllegalStateException("Unable to find any namespaces for the Gitlab group configured. Group: " + gitlabProperties.getGroup());
        }

        //Set the group namespace to the first one we find
        group = namespaces.get(0);

        systemHookManager.addListener(this);
        webHookManager.addListener(this);
        logger.info("GitlabClientImpl Initialized");
    }

    void setGroup(Namespace group) {
        this.group = group;
    }

    @Override
    public void setItemEventListener(ItemEventListener listener) {
        projectListener = listener;
    }

    @Override
    public void handleSystemHook(HttpServletRequest request) {
        try {
            // This method parses the data and then invokes the SystemHookListener overrides
            // in this class based on the contents.
            systemHookManager.handleEvent(request);
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to handle system hook call {}", request);
        }
    }

    @Override
    public void handleWebHook(HttpServletRequest request) {
        try {
            // This method parses the data and then invokes the WebHookListener overrides
            // in this class based on the contents.
            webHookManager.handleEvent(request);
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to handle web hook call {}", request);
        }
    }

    @Override
    public void monitorItem(int itemBankId) {
        logger.debug("Adding project push hook id {} url {}", itemBankId, gitlabProperties.getWebhookUrl());

        final Optional<ProjectHook> createdProjectHook = gitLabRepository.addProjectHook(itemBankId);
        if (!createdProjectHook.isPresent()) {
            throw new GitLabApiRuntimeException(String.format("Could not create a project hook for itemBankId %d", itemBankId));
        }
    }

    @Override
    public void onProjectEvent(ProjectSystemHookEvent event) {
        logger.debug("onProjectEvent path {}", event.getPathWithNamespace());

        // If the project listener is null, no action can be taken
        if (projectListener == null) {
            return;
        }

        // If the group path isn't one we're configured to handle, the event should be ignored
        if (!event.getPathWithNamespace().startsWith(group.getPath())) {
            return;
        }

        switch (event.getClass().getSimpleName()) {
            case PROJECT_CREATE_EVENT:
                projectListener.onCreateItem(event.getProjectId());
                break;
            case PROJECT_DESTROY_EVENT:
                projectListener.onDeleteItem(event.getProjectId());
                break;
            default:
                break;
        }
    }

    @Override
    public void onPushEvent(PushEvent pushEvent) {
        logger.debug("onPushEvent ref {} branch {} path {} id {}",
                pushEvent.getRef(), pushEvent.getBranch(), pushEvent.getProject().getPathWithNamespace(),
                pushEvent.getProjectId());
        // Check to see that this is a push into the master branch
        if (projectListener != null && pushEvent.getBranch().equals("master")) {
            // If so, notify the listener
            logger.debug("onPushEvent ref {} branch {} path {} id {}",
                    pushEvent.getRef(), pushEvent.getBranch(), pushEvent.getProject().getPathWithNamespace(),
                    pushEvent.getProjectId());
            projectListener.onUpdateItem(pushEvent.getProjectId());
        }
    }

    @Override
    public List<ItemBankItemRevision> getItemHistory(int itemBankId, ItemGitInformation existingGitInfo) {
        Instant since = existingGitInfo != null ? existingGitInfo.getCurrentCommitDate() : Instant.ofEpochSecond(0);
        String branchName = MASTER_BRANCH_NAME;
        if ((null == existingGitInfo || existingGitInfo.getItem().isBeingCreated()) && !itemExistsOnMaster(itemBankId)) {
            // If item.json does not exist on the master branch, find the create branch
            // TODO - Should this throw or should the calling handler get a Not Found or something to indicate it couldn't find the item?
            branchName = findCreateBranch(itemBankId, existingGitInfo)
                    .orElseThrow(() -> new GitLabApiRuntimeException("Unable to find create_<user> branch for itemBankId %s", itemBankId));
        }
        logger.debug("Using branch {} for itemBankId {}", branchName, itemBankId);
        // GitLab will only allow returning limited number of commits per page.
        // To make sure we get them all, we will use paging.
        Pager<Commit> commitPager = gitLabRepository.findAllCommitsForFile(itemBankId,
                ITEM_FILE_NAME,
                branchName,
                Date.from(since),
                null,
                MAX_ITEMS_PER_PAGE)
                .orElseThrow(() -> new GitLabApiRuntimeException(String.format("Unable to retrieve commits for itemBankId %s since %s",
                        itemBankId, since)));

        List<Commit> commits = Lists.newArrayList();
        while (commitPager.hasNext()) {
            commits.addAll(commitPager.next());
        }
        // Gitlab returns the list newest first, we want oldest first
        Collections.reverse(commits);
        List<ItemBankItemRevision> itemBankItemRevisions = Lists.newArrayListWithCapacity(commits.size());
        for (Commit commit : commits) {
            itemBankItemRevisions.add(generateRevision(itemBankId, commit, branchName));
        }
        return itemBankItemRevisions;

    }

    /**
     * Checks to see if item.json exists on the master branch yet
     *
     * @param itemBankId item bank item id
     * @return true if item.json exists on the master branch, otherwise false
     * @throws GitLabApiRuntimeException if an unexpected exception occurs
     */
    private boolean itemExistsOnMaster(int itemBankId) {
        logger.debug("Checking to see if item exists on master for itemBankId {}", itemBankId);

        return gitLabRepository.findFile(itemBankId, ITEM_FILE_NAME, MASTER_BRANCH_NAME)
                .isPresent();
    }

    /**
     * Find the name of the create_<user> branch for an itemBank item
     *
     * @param itemBankId      item bank item id
     * @param existingGitInfo existing info, may be null
     * @return the name of the branch
     */
    private Optional<String> findCreateBranch(int itemBankId, ItemGitInformation existingGitInfo) {
        logger.debug("findCreateBranch for itemBankId {}", itemBankId);
        if (null != existingGitInfo) {
            logger.debug("Use existing create branch {} for itemBankId {}", existingGitInfo.getIngestSource(), itemBankId);
            return Optional.of(existingGitInfo.getIngestSource());
        }

        List<Branch> branches = gitLabRepository.getAllBranches(itemBankId);
        for (Branch branch : branches) {
            if (branch.getName().startsWith(CREATE_BRANCH_PREFIX)) {
                logger.debug("Found create branch {} for itemBankId {}", branch.getName(), itemBankId);
                return Optional.of(branch.getName());
            }
        }


        return Optional.empty();
    }

    @Override
    public List<Integer> getAllItemBankIds() {
        final List<Integer> projectIds = new ArrayList<>();

        final Pager<Project> projectPager = gitLabRepository.findAllProjects(MAX_ITEMS_PER_PAGE)
                .orElseThrow(() -> new GitLabApiRuntimeException("Unable to retrieve project ids from group " + group.getName()));

        while (projectPager.hasNext()) {
            final List<Project> projects = projectPager.next();

            List<Integer> validProjectIds = projects.stream()
                    .filter(project -> project.getPathWithNamespace().startsWith(group.getPath()))
                    .map(Project::getId).collect(Collectors.toList());

            projectIds.addAll(validProjectIds);
        }

        return projectIds;
    }

    @Override
    public boolean isProjectMonitored(final int projectId) {
        final List<ProjectHook> projectHooks = gitLabRepository.getAllProjectHooks(projectId);

        return projectHooks.stream().anyMatch(h -> h.getUrl().equals(gitlabProperties.getWebhookUrl()));
    }

    @Override
    public void onTeamMemberEvent(TeamMemberSystemHookEvent event) {

    }

    @Override
    public void onUserEvent(UserSystemHookEvent event) {

    }

    @Override
    public void onKeyEvent(KeySystemHookEvent event) {

    }

    @Override
    public void onGroupEvent(GroupSystemHookEvent event) {

    }

    @Override
    public void onGroupMemberEvent(GroupMemberSystemHookEvent event) {

    }

    @Override
    public void onPushEvent(PushSystemHookEvent event) {

    }

    @Override
    public void onTagPushEvent(TagPushSystemHookEvent event) {

    }

    @Override
    public void onRepositoryEvent(RepositorySystemHookEvent event) {

    }

    @Override
    public void onBuildEvent(BuildEvent buildEvent) {

    }

    @Override
    public void onIssueEvent(IssueEvent event) {

    }

    @Override
    public void onMergeRequestEvent(MergeRequestEvent event) {
    }

    @Override
    public void onNoteEvent(NoteEvent noteEvent) {

    }

    @Override
    public void onPipelineEvent(PipelineEvent pipelineEvent) {

    }

    @Override
    public void onTagPushEvent(TagPushEvent tagPushEvent) {

    }

    @Override
    public void onWikiPageEvent(WikiPageEvent wikiEvent) {

    }

    /**
     * Generates an ItemBankItemRevision object for a given commit on item.json
     *
     * @param itemBankId item bank item id
     * @param commit     revision information
     * @return ItemBankItemRevision object containing details on the revision
     */
    private ItemBankItemRevision generateRevision(int itemBankId, Commit commit, String branch) {
        RepositoryFile itemFile = gitLabRepository.findFile(itemBankId, ITEM_FILE_NAME, branch)
                .orElseThrow(() -> new GitLabApiRuntimeException(String.format("Unexpected error accessing %s for itembank %s", ITEM_FILE_NAME, itemBankId)));

        byte json[] = Base64.getDecoder().decode(itemFile.getContent());
        // This will throw a runtime exception if there is a problem converting the item
        Item item = itemParser.readItem(json);
        return new ItemBankItemRevision(itemBankId, gitlabProperties.getGroup(), item, commit.getId(),
                commit.getCommittedDate().toInstant(), commit.getAuthorName(), !branch.equals(MASTER_BRANCH_NAME), branch);
    }
}
