package org.opentestsystem.ap.imrt.iis.client;

import com.google.common.collect.Lists;
import org.gitlab4j.api.GitLabApi;
import org.gitlab4j.api.GitLabApiException;
import org.gitlab4j.api.Pager;
import org.gitlab4j.api.models.Commit;
import org.gitlab4j.api.models.Namespace;
import org.gitlab4j.api.models.Project;
import org.gitlab4j.api.models.ProjectHook;
import org.gitlab4j.api.models.RepositoryFile;
import org.gitlab4j.api.systemhooks.GroupMemberSystemHookEvent;
import org.gitlab4j.api.systemhooks.GroupSystemHookEvent;
import org.gitlab4j.api.systemhooks.KeySystemHookEvent;
import org.gitlab4j.api.systemhooks.ProjectSystemHookEvent;
import org.gitlab4j.api.systemhooks.PushSystemHookEvent;
import org.gitlab4j.api.systemhooks.RepositorySystemHookEvent;
import org.gitlab4j.api.systemhooks.SystemHookListener;
import org.gitlab4j.api.systemhooks.SystemHookManager;
import org.gitlab4j.api.systemhooks.TagPushSystemHookEvent;
import org.gitlab4j.api.systemhooks.TeamMemberSystemHookEvent;
import org.gitlab4j.api.systemhooks.UserSystemHookEvent;
import org.gitlab4j.api.webhook.BuildEvent;
import org.gitlab4j.api.webhook.IssueEvent;
import org.gitlab4j.api.webhook.MergeRequestEvent;
import org.gitlab4j.api.webhook.NoteEvent;
import org.gitlab4j.api.webhook.PipelineEvent;
import org.gitlab4j.api.webhook.PushEvent;
import org.gitlab4j.api.webhook.TagPushEvent;
import org.gitlab4j.api.webhook.WebHookListener;
import org.gitlab4j.api.webhook.WebHookManager;
import org.gitlab4j.api.webhook.WikiPageEvent;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.config.ItemBankProperties;
import org.opentestsystem.ap.imrt.iis.exception.GitLabApiRuntimeException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletRequest;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Wrapper around the gitlab4j java web client:
 * https://github.com/gmessner/gitlab4j-api
 */
@Component
@ConditionalOnProperty(value = "test.enabled", havingValue = "false", matchIfMissing = true)
public class GitlabClientImpl implements SystemHookListener, WebHookListener, ItemBankClient, GitlabHookClient {
    private static final Logger logger = LoggerFactory.getLogger(GitlabClientImpl.class);
    private static final String BRANCH_NAME = "master";
    private static final String ITEM_FILE_NAME = "item.json";
    private static final int MAX_ITEMS_PER_PAGE = 100;

    private final ItemBankProperties gitlabProperties;
    private GitLabApi gitLabApi;
    private Namespace group;
    private final SystemHookManager systemHookManager = new SystemHookManager();
    private final WebHookManager webHookManager = new WebHookManager();
    private ItemEventListener projectListener;
    private final OperationalEventService operationalEventService;
    private final ItemParser itemParser;

    @Autowired
    public GitlabClientImpl(ItemBankProperties gitlabProperties, OperationalEventService operationalEventService,
                            ItemParser itemParser) {
        this.gitlabProperties = gitlabProperties;
        this.operationalEventService = operationalEventService;
        this.itemParser = itemParser;
    }

    @PostConstruct
    public void init() {
        gitLabApi = new GitLabApi(gitlabProperties.getHost(), gitlabProperties.getAccessToken());
        try {
            group = gitLabApi.getNamespaceApi().findNamespaces(gitlabProperties.getGroup()).get(0);
            systemHookManager.addListener(this);
            webHookManager.addListener(this);
            logger.info("GitlabClientImpl Initialized");
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to find group {}", gitlabProperties.getGroup());
            // Cause spring init to fail
            throw new GitLabApiRuntimeException(e);
        }
    }

    @Override
    public void setItemEventListener(ItemEventListener listener) {
        projectListener = listener;
    }

    @Override
    public void handleSystemHook(HttpServletRequest request) {
        try {
            // This method parses the data and then invokes the SystemHookListener overrides
            // in this class based on the contents.
            systemHookManager.handleEvent(request);
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to handle system hook call {}", request);
        }
    }

    @Override
    public void handleWebHook(HttpServletRequest request) {
        try {
            // This method parses the data and then invokes the WebHookListener overrides
            // in this class based on the contents.
            webHookManager.handleEvent(request);
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to handle web hook call {}", request);
        }
    }

    @Override
    public void monitorItem(int itemBankId) {
        logger.debug("Adding project push hook id {} url {}", itemBankId, gitlabProperties.getWebhookUrl());
        try {
            gitLabApi.getProjectApi().addHook(itemBankId, gitlabProperties.getWebhookUrl(), true, false, false);
        } catch (GitLabApiException e) {
            // Generate an event
            operationalEventService.serviceError(logger, e, "Unable to register webhook for projectId/itemBankId {}", itemBankId);
        }
    }

    @Override
    public void onProjectEvent(ProjectSystemHookEvent event) {
        logger.debug("onProjectEvent path {}", event.getPathWithNamespace());
        // Check to see if this is a project create event for our group
        if (projectListener != null && event.getClass().getSimpleName().equals("CreateProjectSystemHookEvent") &&
                event.getPathWithNamespace().startsWith(group.getPath())) {
            // If so, notify our listener
            projectListener.onCreateItem(event.getProjectId());
        }
    }

    @Override
    public void onTeamMemberEvent(TeamMemberSystemHookEvent event) {

    }

    @Override
    public void onUserEvent(UserSystemHookEvent event) {

    }

    @Override
    public void onKeyEvent(KeySystemHookEvent event) {

    }

    @Override
    public void onGroupEvent(GroupSystemHookEvent event) {

    }

    @Override
    public void onGroupMemberEvent(GroupMemberSystemHookEvent event) {

    }

    @Override
    public void onPushEvent(PushSystemHookEvent event) {

    }

    @Override
    public void onTagPushEvent(TagPushSystemHookEvent event) {

    }

    @Override
    public void onRepositoryEvent(RepositorySystemHookEvent event) {

    }

    @Override
    public void onBuildEvent(BuildEvent buildEvent) {

    }

    @Override
    public void onIssueEvent(IssueEvent event) {

    }

    @Override
    public void onMergeRequestEvent(MergeRequestEvent event) {
    }

    @Override
    public void onNoteEvent(NoteEvent noteEvent) {

    }

    @Override
    public void onPipelineEvent(PipelineEvent pipelineEvent) {

    }

    @Override
    public void onPushEvent(PushEvent pushEvent) {
        logger.debug("onPushEvent ref {} branch {} path {} id {}",
                pushEvent.getRef(), pushEvent.getBranch(), pushEvent.getProject().getPathWithNamespace(),
                pushEvent.getProjectId());
        // Check to see that this is a push into the master branch
        if (projectListener != null && pushEvent.getBranch().equals("master")) {
            // If so, notify the listener
            logger.debug("onPushEvent ref {} branch {} path {} id {}",
                    pushEvent.getRef(), pushEvent.getBranch(), pushEvent.getProject().getPathWithNamespace(),
                    pushEvent.getProjectId());
            projectListener.onUpdateItem(pushEvent.getProjectId());
        }
    }

    @Override
    public void onTagPushEvent(TagPushEvent tagPushEvent) {

    }

    @Override
    public void onWikiPageEvent(WikiPageEvent wikiEvent) {

    }

    void setGitLabApi(GitLabApi gitLabApi) {
        this.gitLabApi = gitLabApi;
    }

    void setGroup(Namespace group) {
        this.group = group;
    }

    @Override
    public List<ItemBankItemRevision> getItemHistory(int itemBankId, Instant since) {
        try {
            // GitLab will only allow returning limited number of commits per page.
            // To make sure we get them all, we will use paging.
            Pager<Commit> commitPager = gitLabApi.getCommitsApi().getCommits(
                    itemBankId, BRANCH_NAME, Date.from(since), null, ITEM_FILE_NAME, MAX_ITEMS_PER_PAGE);
            List<Commit> commits = Lists.newArrayList();
            while(commitPager.hasNext()) {
                 commits.addAll(commitPager.next());
            }
            // Gitlab returns the list newest first, we want oldest first
            Collections.reverse(commits);
            List<ItemBankItemRevision> itemBankItemRevisions = Lists.newArrayListWithCapacity(commits.size());
            for (Commit commit : commits) {
                itemBankItemRevisions.add(generateRevision(itemBankId, commit));
            }
            return itemBankItemRevisions;
        } catch (GitLabApiException e) {
            // If there are no commits for item.json, then the above call returns an empty list.
            // So any exception means something went wrong
            operationalEventService.serviceError(logger, e, "Unable to retrieve history for itemId {} since {}",
                    itemBankId, since);
            throw new GitLabApiRuntimeException(e);
        }
    }

    @Override
    public List<Integer> getAllItemBankIds() {
        final List<Integer> projectIds = new ArrayList<>();

        try {
            final Pager<Project> projectPager = gitLabApi.getProjectApi().getProjects(MAX_ITEMS_PER_PAGE);
            while (projectPager.hasNext()) {
                final List<Project> projects = projectPager.next();

                projectIds.addAll(projects.stream().map(Project::getId).collect(Collectors.toList()));
            }
        } catch (GitLabApiException e) {
            operationalEventService.serviceError(logger, e, "Unable to retrieve project ids from group '{}'", group.getName());

            throw new GitLabApiRuntimeException(e);
        }

        return projectIds;
    }

    @Override
    public boolean isProjectMonitored(final int projectId) {
        try {
            final List<ProjectHook> projectHooks = gitLabApi.getProjectApi().getHooks(projectId);

            return projectHooks.stream().anyMatch(h -> h.getUrl().equals(gitlabProperties.getWebhookUrl()));
        } catch (GitLabApiException e) {
            operationalEventService.serviceError(logger, e, "Unable to retrieve project hooks for project {}", projectId);

            throw new GitLabApiRuntimeException(e);
        }
    }

    /**
     * Generates an ItemBankItemRevision object for a given commit on item.json
     *
     * @param itemId item bank item id
     * @param commit revision information
     * @return ItemBankItemRevision object containing details on the revision
     * @throws GitLabApiException if there is a problem communicating with GitLab
     */
    private ItemBankItemRevision generateRevision(int itemId, Commit commit) throws GitLabApiException {
        RepositoryFile itemFile = gitLabApi.getRepositoryFileApi().getFile(ITEM_FILE_NAME, itemId, commit.getId());
        byte json[] = Base64.getDecoder().decode(itemFile.getContent());
        // This will throw a runtime exception if there is a problem converting the item
        Item item = itemParser.readItem(json);
        return new ItemBankItemRevision(itemId, gitlabProperties.getGroup(), item, commit.getId(),
                commit.getCommittedDate().toInstant(), commit.getAuthorName());
    }
}
