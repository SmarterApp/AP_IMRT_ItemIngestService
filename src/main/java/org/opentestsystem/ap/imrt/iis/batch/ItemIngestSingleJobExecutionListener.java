package org.opentestsystem.ap.imrt.iis.batch;

import org.apache.commons.lang.exception.ExceptionUtils;
import org.opentestsystem.ap.imrt.iis.model.ItemIngestJobResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobExecutionListener;
import org.springframework.stereotype.Component;

import java.util.Optional;

/**
 * A {@link org.springframework.batch.core.JobExecutionListener} that prevents an item ingest
 * {@link org.springframework.batch.core.Job}s from running more than one instance at a time.
 */
@Component
public class ItemIngestSingleJobExecutionListener implements JobExecutionListener {
    // The active job execution, which will act as a lock.
    private JobExecution activeJob;
    private static final Logger logger = LoggerFactory.getLogger(ItemIngestSingleJobExecutionListener.class);

    @Override
    public void beforeJob(final JobExecution jobExecution) {
        // Create a lock to examine the active job.  If the active job is already running, prevent the execution of
        // the new job request.
        synchronized (jobExecution) {
            if (activeJob != null && activeJob.isRunning()) {
                logger.warn("An {} with Job execution id: {} is already running.  Wait for this job to complete before starting another one.", activeJob.getJobInstance().getJobName(), activeJob.getId());
                jobExecution.stop();
            } else {
                activeJob = jobExecution;
                logger.info("{} starting.  Job execution id: {}", activeJob.getJobInstance().getJobName(), activeJob.getId());
            }
        }
    }

    @Override
    public void afterJob(final JobExecution jobExecution) {
        // Log completion of the job.  If the job ran into an exception, capture the stack trace.
        String exitStatusMessage;
        if (jobExecution.getAllFailureExceptions().isEmpty()) {
            final Optional<ItemIngestJobResponse> response =
                    Optional.ofNullable((ItemIngestJobResponse) jobExecution.getExecutionContext().get(ItemIngestJobResponse.EXECUTION_CONTEXT_DATA_KEY));

            exitStatusMessage = response.map(ItemIngestJobResponse::toString)
                    .orElse(String.format("No response data from %s execution for Job execution id: %d.", jobExecution.getJobInstance().getJobName(), jobExecution.getId()));
        } else {
            final String[] exceptionMessages = jobExecution.getAllFailureExceptions().stream()
                    .map(throwable -> String.format("%s: %s", throwable.getMessage(), ExceptionUtils.getStackTrace(throwable)))
                    .toArray(String[]::new);
            exitStatusMessage = String.join("\n", exceptionMessages);
        }

        jobExecution.setExitStatus(new ExitStatus(jobExecution.getExitStatus().getExitCode(), exitStatusMessage));

        logger.info("{} Job complete.  Job execution id: {}, exit status code: {}, exit message: {}",
                jobExecution.getJobInstance().getJobName(),
                jobExecution.getId(),
                jobExecution.getExitStatus().getExitCode(),
                exitStatusMessage);

        // Release the lock
        synchronized (jobExecution) {
            if (jobExecution.equals(activeJob)) {
                activeJob = null;
            }
        }
    }
}
