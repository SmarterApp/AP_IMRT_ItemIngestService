package org.opentestsystem.ap.imrt.iis.service;

import org.opentestsystem.ap.imrt.common.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.common.service.OperationalEventService;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.exception.ItemIngestException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevisionImpl;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 * <p>
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
public class ItemUpdateNotificationHandlerImpl implements ItemUpdateNotificationHandler {
    private static final Logger LOG = LoggerFactory.getLogger(ItemUpdateNotificationHandlerImpl.class);

    private final ProjectLockService projectLockService;
    private final ItemBankClient itemBankClient;
    private final ItemRevisionWriter itemRevisionWriter;
    private final ItemGitInformationRepository itemGitInformationRepository;
    private final OperationalEventService logger;
    private final ItemRevisionProcessor businessRuleRunner;

    public ItemUpdateNotificationHandlerImpl(ProjectLockService projectLockService, ItemBankClient itemBankClient,
                                             ItemRevisionWriter itemRevisionWriter, ItemGitInformationRepository itemGitInformationRepository,
                                             OperationalEventService logger, ItemRevisionProcessor itemRevisionProcessor) {
        this.projectLockService = projectLockService;
        this.itemBankClient = itemBankClient;
        this.itemRevisionWriter = itemRevisionWriter;
        this.itemGitInformationRepository = itemGitInformationRepository;
        this.logger = logger;
        this.businessRuleRunner = itemRevisionProcessor;
    }

    @Override
    public ItemGitInformation processItemMessage(Integer itemBankId) {
        logger.debug(LOG, "Received update message for itembank id {}", itemBankId);

        // Lock the project first. Make sure we always unlock it in the finally clause
        long lock = projectLockService.lockProject(itemBankId);

        logger.debug(LOG, "Acquired lock for item id {}", itemBankId);
        try {
            // We got the lock, so process the update
            return syncItemToItemBank(itemBankId);
        } finally {
            logger.debug(LOG, "Released lock for item id {}", itemBankId);
            projectLockService.unlockProject(itemBankId, lock);
        }
    }

    @Override
    public ItemGitInformation migrateItem(final ItemGitInformation itemGitInformation) {
        long lock = projectLockService.lockProject(itemGitInformation.getProjectId());

        try {
            final ItemBankItemRevision itemBankItemRevision = itemBankClient.getItemBankItemRevision(itemGitInformation);
            return syncItemRevision(itemGitInformation, itemBankItemRevision);
        } finally {
            projectLockService.unlockProject(itemGitInformation.getProjectId(), lock);
        }
    }

    /**
     * Synchronize an item to the item bank, by ingesting any revisions we have not
     * already processed.
     *
     * @param itemBankId the item bank id for the item.
     */
    private ItemGitInformation syncItemToItemBank(int itemBankId) {
        // See if we have any existing itemGitInformation for this item in the database
        ItemGitInformation existingGitInfo = itemGitInformationRepository.findOne(itemBankId);

        if (existingGitInfo != null) {
            logger.debug(LOG, "ItemGitInformation found {} commitId {} date {}", existingGitInfo,
                    existingGitInfo.getCurrentCommitHash(),
                    existingGitInfo.getCurrentCommitDate());
        } else {
            logger.debug(LOG, "No ItemGitInformation found for itembank id {}", itemBankId);
        }

        // Get the history of the item since we last processed it
        List<ItemBankItemRevision> itemHistoryList = getItemHistorySinceLastProcessed(itemBankId, existingGitInfo);

        // Sync each change
        for (ItemBankItemRevision revision : itemHistoryList) {
            existingGitInfo = syncItemRevision(existingGitInfo, revision);
        }

        return existingGitInfo;
    }

    /**
     * Synchronize a single revision of an item
     *
     * @param existingGitInfo      the previous item that was synchronized. May be null
     * @param itemBankItemRevision the itemBankItemRevision details for the revision
     * @return the ItemGitInformation object for the item revision that was synchronized
     */
    private ItemGitInformation syncItemRevision(ItemGitInformation existingGitInfo, ItemBankItemRevision itemBankItemRevision) {
        LOG.debug("Synchronizing revision: date {} id {} name {}", itemBankItemRevision.getRevisionDate(), itemBankItemRevision.getRevisionId(),
                itemBankItemRevision.getAuthor());

        // Create an ItemRevision
        ItemRevision revision = new ItemRevisionImpl(itemBankItemRevision, existingGitInfo);

        revision = businessRuleRunner.applyRules(existingGitInfo, revision);

        try {
            // Save to the DB
            itemRevisionWriter.saveItemRevision(revision);
        } catch (Exception e) {
            //Log item and project information.  By rethrowing the higher level error handler will log the Exception itself so we don't log it again here.
            throw new ItemIngestException(e, "Item id %s failed to save.  Revision %s", revision.getItem().getId(), itemBankItemRevision);
        }

        // Generate operational event for the item create/update
        generateItemEvent(existingGitInfo, revision);

        // Update our existing info to what we just saved
        existingGitInfo = revision.getItemGitInformation();
        return existingGitInfo;
    }

    /**
     * Generate an itemCreated or an itemUpdate event
     *
     * @param existingGitInfo used to determine if this is a create or an update
     * @param revision        ItemRevision that was created or updated
     */
    private void generateItemEvent(ItemGitInformation existingGitInfo, ItemRevision revision) {
        if (null == existingGitInfo) {
            logger.itemCreatedEvent(LOG, revision.getItem().getKey(),
                    revision.getItem().getId(), revision.getItemGitInformation().getProjectId());
        } else {
            logger.itemUpdatedEvent(LOG, revision.getItem().getKey(),
                    revision.getItem().getId(), revision.getItemGitInformation().getProjectId());
        }
    }

    /**
     * Get the history of an item from the itembank
     *
     * @param itemBankId      the item bank id for the item.
     * @param existingGitInfo information about the last commit we processed for this item. May be null
     * @return an historical list of {@link ItemBankItemRevision} for the item that have occurred since the last revision processed,
     * or since the dawn of time if existingGitInfo is null.
     */
    private List<ItemBankItemRevision> getItemHistorySinceLastProcessed(int itemBankId, ItemGitInformation existingGitInfo) {
        // Get the history of the item from the item bank, going back to the last update
        // we processed, or the dawn of time if existingGitInfo is null
        List<ItemBankItemRevision> itemHistoryList = itemBankClient.getItemHistory(itemBankId, existingGitInfo);

        LOG.debug("Total commits {}", itemHistoryList.size());
        // Generally the first item returned is the last one we processed. We could increase the since
        // time, but the granularity is seconds, and we want to be very sure we never miss a commit
        // so instead we will remove the first item from the list if we have already processed it
        if (itemHistoryList.size() > 0
                && existingGitInfo != null
                && itemHistoryList.get(0).getRevisionId().equals(existingGitInfo.getCurrentCommitHash())) {
            itemHistoryList.remove(0);
            LOG.debug("Removing first commit {} from the list as we have already processed it.",
                    existingGitInfo.getCurrentCommitHash());
        }
        return itemHistoryList;
    }

}
