package org.opentestsystem.ap.imrt.iis.service.impl;

import org.opentestsystem.ap.common.imrt.model.BaseItem;
import org.opentestsystem.ap.common.imrt.repository.BaseItemRepository;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.common.rest.item.ItemCommitResponse;
import org.opentestsystem.ap.common.rest.item.ItemEntityResponse;
import org.opentestsystem.ap.imrt.iis.core.ItemBankMapper;
import org.opentestsystem.ap.imrt.iis.exception.ItemIngestException;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemUpdateEvent;
import org.opentestsystem.ap.imrt.iis.service.ItemIngestService;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionProcessor;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionService;
import org.opentestsystem.ap.imrt.iis.service.ItemService;
import org.opentestsystem.ap.imrt.iis.service.ItemWorkQueueService;
import org.opentestsystem.ap.imrt.iis.service.ProjectLockService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Optional;
import java.util.UUID;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 * <p>
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
public class ItemIngestServiceImpl implements ItemIngestService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemIngestServiceImpl.class);

    private final ProjectLockService projectLockService;
    private final ItemRevisionService itemRevisionService;
    private final OperationalEventService logger;
    private final ItemRevisionProcessor itemRevisionProcessor;
    private final ItemBankMapper itemBankMapper;
    private final ItemWorkQueueService itemWorkQueueService;
    private final ItemService itemService;
    private final BaseItemRepository baseItemRepository;

    public ItemIngestServiceImpl(ProjectLockService projectLockService,
                                 ItemRevisionService itemRevisionService,
                                 OperationalEventService logger,
                                 ItemRevisionProcessor itemRevisionProcessor,
                                 ItemBankMapper itemBankMapper,
                                 final ItemWorkQueueService itemWorkQueueService,
                                 final ItemService itemService, final BaseItemRepository baseItemRepository) {
        this.projectLockService = projectLockService;
        this.itemRevisionService = itemRevisionService;
        this.logger = logger;
        this.itemRevisionProcessor = itemRevisionProcessor;
        this.itemBankMapper = itemBankMapper;
        this.itemWorkQueueService = itemWorkQueueService;
        this.itemService = itemService;
        this.baseItemRepository = baseItemRepository;
    }

    @Override
    public void syncItem(ItemUpdateEvent itemUpdateEvent) {
        logger.info(LOG, "Received update message for item id {}", itemUpdateEvent.getItemId());

        // Lock the project first. Make sure we always unlock it in the finally clause
        long lock = projectLockService.lockProject(itemUpdateEvent.getItemId());

        logger.debug(LOG, "Acquired lock for item id {}", itemUpdateEvent.getItemId());
        try {
            // We got the lock, so process the update);
            syncItemToItemBank(itemUpdateEvent);
            logger.info(LOG, "Synced itembank " + itemUpdateEvent.getItemId());
        } finally {
            logger.debug(LOG, "Released lock for item id {}", itemUpdateEvent.getItemId());
            projectLockService.unlockProject(itemUpdateEvent.getItemId(), lock);
        }
    }

    @Override
    public boolean syncItemWithLatestRevision(final ItemUpdateEvent itemUpdateEvent) {
        int itemId = itemUpdateEvent.getItemId();

        long lock = projectLockService.lockProject(itemId);

        try {
            Optional<ItemEntityResponse> maybeItemEntityResponse = itemService.findItemEntityById(itemUpdateEvent.getCommitId());
            if (!maybeItemEntityResponse.isPresent()) {
                return false;
            }

            BaseItem baseItem = baseItemRepository.findById(itemId);

            syncItemRevision(itemUpdateEvent, Optional.ofNullable(baseItem), maybeItemEntityResponse.get());
            itemWorkQueueService.sendItemValidationMessage(itemId);

            return true;
        } finally {
            projectLockService.unlockProject(itemId, lock);
        }
    }

    private void syncItemToItemBank(ItemUpdateEvent itemUpdateEvent) {
        // See if we have any existing itemGitInformation for this item in the database
        Optional<BaseItem> maybeCurrentItem = Optional.ofNullable(baseItemRepository.findById(itemUpdateEvent.getItemId()));

        ItemCommitResponse itemCommitResponse = findCommits(itemUpdateEvent.getItemId(), maybeCurrentItem);

        UUID previousCommitHash = maybeCurrentItem.map(BaseItem::getCommitId).orElse(null);
        BaseItem currentItem = maybeCurrentItem.orElse(null);

        // Sync each change
        for (UUID commit : itemCommitResponse.getCommits()) {
            Optional<ItemEntityResponse> maybeItemEntityResponse = itemService.findItemEntityById(commit);
            if (!maybeItemEntityResponse.isPresent()) {
                logger.error(LOG, null, "Item {} with commit {} could not be found in TIMS", itemUpdateEvent.getItemId(), commit);
                continue;
            }
            currentItem = syncItemRevision(itemUpdateEvent, maybeCurrentItem, maybeItemEntityResponse.get());
        }

        if (currentItem != null && (previousCommitHash == null || !previousCommitHash.equals(currentItem.getCommitId()))) {
            //Validate item
            itemWorkQueueService.sendItemValidationMessage(currentItem.getId());
        }
    }

    private BaseItem syncItemRevision(ItemUpdateEvent itemUpdateEvent, Optional<BaseItem> imrtItem, ItemEntityResponse itemEntityResponse) {
        Item existingItem = null;

        if (imrtItem.isPresent()) {
            existingItem = imrtItem.get().getItemJson();
        }

        // Create an ItemRevision
        ItemRevision revision = itemBankMapper.map(itemUpdateEvent, itemEntityResponse, imrtItem.orElse(null));

        revision = itemRevisionProcessor.applyRules(imrtItem.orElse(null), existingItem, revision);

        try {
            // Save to the DB
            itemRevisionService.save(revision);
        } catch (Exception e) {
            //Log item and project information.  By rethrowing the higher level error handler will log the Exception itself so we don't log it again here.
            throw new ItemIngestException(e, "Item id %s failed to save.  Revision %s", revision.getItem().getId(), revision);
        }

        // Generate operational event for the item create/update
        logItemEvent(imrtItem.isPresent(), revision);

        // Update our existing info to what we just saved
        return revision.getItem();
    }

    private void logItemEvent(boolean existingItem, ItemRevision revision) {
        if (!existingItem) {
            logger.itemCreatedEvent(LOG, revision.getItem().getKey(),
                    revision.getItem().getId());
        } else {
            logger.itemUpdatedEvent(LOG,
                    revision.getItem().getKey(),
                    revision.getItem().getId(),
                    revision.getItem().getCommitId().toString());
        }
    }

    private ItemCommitResponse findCommits(int itemId, Optional<BaseItem> baseItem) {
        if (baseItem.isPresent()) {
            // Get the history of the item since we last processed it
            return itemService.findMasterItemCommitsSinceCommit(itemId, baseItem.get().getCommitId());
        } else {
            return itemService.findAllCommits(itemId).orElseThrow(() -> new RuntimeException("Failed to find any item commits for item " + itemId));
        }
    }
}
