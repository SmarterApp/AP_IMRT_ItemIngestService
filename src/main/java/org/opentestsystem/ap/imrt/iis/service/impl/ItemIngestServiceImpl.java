package org.opentestsystem.ap.imrt.iis.service.impl;

import org.opentestsystem.ap.common.imrt.model.ItemGitInformation;
import org.opentestsystem.ap.common.imrt.service.OperationalEventService;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.core.ItemBankMapper;
import org.opentestsystem.ap.imrt.iis.exception.ItemIngestException;
import org.opentestsystem.ap.imrt.iis.model.ItemBankCommit;
import org.opentestsystem.ap.imrt.iis.model.ItemBankItemRevision;
import org.opentestsystem.ap.imrt.iis.model.ItemRevision;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.opentestsystem.ap.imrt.iis.service.ItemIngestService;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionProcessor;
import org.opentestsystem.ap.imrt.iis.service.ItemRevisionService;
import org.opentestsystem.ap.imrt.iis.service.ItemWorkQueueService;
import org.opentestsystem.ap.imrt.iis.service.ProjectLockService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

import static org.apache.commons.lang3.StringUtils.EMPTY;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 * <p>
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
public class ItemIngestServiceImpl implements ItemIngestService {
    private static final Logger LOG = LoggerFactory.getLogger(ItemIngestServiceImpl.class);

    private final ProjectLockService projectLockService;
    private final ItemBankClient itemBankClient;
    private final ItemRevisionService itemRevisionService;
    private final ItemGitInformationRepository itemGitInformationRepository;
    private final OperationalEventService logger;
    private final ItemRevisionProcessor itemRevisionProcessor;
    private final ItemBankMapper itemBankMapper;
    private final ItemWorkQueueService itemWorkQueueService;

    public ItemIngestServiceImpl(ProjectLockService projectLockService,
                                 ItemBankClient itemBankClient,
                                 ItemRevisionService itemRevisionService,
                                 ItemGitInformationRepository itemGitInformationRepository,
                                 OperationalEventService logger,
                                 ItemRevisionProcessor itemRevisionProcessor,
                                 ItemBankMapper itemBankMapper,
                                 final ItemWorkQueueService itemWorkQueueService) {
        this.projectLockService = projectLockService;
        this.itemBankClient = itemBankClient;
        this.itemRevisionService = itemRevisionService;
        this.itemGitInformationRepository = itemGitInformationRepository;
        this.logger = logger;
        this.itemRevisionProcessor = itemRevisionProcessor;
        this.itemBankMapper = itemBankMapper;
        this.itemWorkQueueService = itemWorkQueueService;
    }

    @Override
    public Optional<ItemGitInformation> syncItem(Integer itemBankId) {
        logger.debug(LOG, "Received update message for itembank id {}", itemBankId);

        // Lock the project first. Make sure we always unlock it in the finally clause
        long lock = projectLockService.lockProject(itemBankId);

        logger.debug(LOG, "Acquired lock for item id {}", itemBankId);
        try {
            // We got the lock, so process the update
            return syncItemToItemBank(itemBankId);
        } finally {
            logger.debug(LOG, "Released lock for item id {}", itemBankId);
            projectLockService.unlockProject(itemBankId, lock);
        }
    }

    @Override
    public Optional<ItemGitInformation> syncItemWithLatestRevision(final ItemGitInformation itemGitInformation) {
        long lock = projectLockService.lockProject(itemGitInformation.getProjectId());

        try {
            if (!itemBankClient.findLatestItemBankItemRevision(itemGitInformation.getProjectId()).isPresent()) {
                return Optional.empty();
            }

            final ItemBankItemRevision itemBankItemRevision = itemBankClient.getItemBankItemRevision(itemGitInformation);
            final ItemGitInformation updatedGitInformation = syncItemRevision(itemGitInformation, itemBankItemRevision);
            itemWorkQueueService.sendItemValidationMessage(updatedGitInformation.getProjectId());

            return Optional.of(updatedGitInformation);
        } finally {
            projectLockService.unlockProject(itemGitInformation.getProjectId(), lock);
        }
    }

    /**
     * Synchronize an item to the item bank, by ingesting any revisions we have not
     * already processed.
     *
     * @param itemBankId the item bank id for the item.
     */
    private Optional<ItemGitInformation> syncItemToItemBank(int itemBankId) {
        //Verify the item bank has an item to process
        if (!itemBankClient.findLatestItemBankItemRevision(itemBankId).isPresent()) {
            return Optional.empty();
        }

        // See if we have any existing itemGitInformation for this item in the database
        ItemGitInformation currentGitInformation = itemGitInformationRepository.findOne(itemBankId);
        String previousCommitHash = currentGitInformation == null ? EMPTY : currentGitInformation.getCurrentCommitHash();

        if (currentGitInformation != null) {
            logger.debug(LOG, "ItemGitInformation found {} commitId {} date {}", currentGitInformation,
                    currentGitInformation.getCurrentCommitHash(),
                    currentGitInformation.getCurrentCommitDate());
        } else {
            logger.debug(LOG, "No ItemGitInformation found for itembank id {}", itemBankId);
        }

        // Get the history of the item since we last processed it
        List<ItemBankCommit> itemHistoryList = getItemHistorySinceLastProcessed(itemBankId, currentGitInformation);

        // Sync each change
        for (ItemBankCommit commit : itemHistoryList) {
            ItemBankItemRevision revision = itemBankClient.getItemBankItemRevision(itemBankId, commit);
            currentGitInformation = syncItemRevision(currentGitInformation, revision);
        }

        if (currentGitInformation != null && !previousCommitHash.equals(currentGitInformation.getCurrentCommitHash())) {
            //Validate item
            itemWorkQueueService.sendItemValidationMessage(currentGitInformation.getProjectId());
        }

        //At this point if the existing git info is null it means that there are no commits.  This should not
        //be possible with Git.
        return Optional.ofNullable(currentGitInformation);
    }

    /**
     * Synchronize a single revision of an item
     *
     * @param currentGitInformation the previous item that was synchronized. May be null
     * @param itemBankItemRevision  the itemBankItemRevision details for the revision
     * @return the ItemGitInformation object for the item revision that was synchronized
     */
    private ItemGitInformation syncItemRevision(ItemGitInformation currentGitInformation, ItemBankItemRevision itemBankItemRevision) {
        logger.debug(LOG, "Synchronizing revision: date {} id {} name {}", itemBankItemRevision.getRevisionDate(), itemBankItemRevision.getRevisionId(),
                itemBankItemRevision.getAuthor());

        Item existingItem = currentGitInformation == null ? null : currentGitInformation.getItem().getItemJson();

        // Create an ItemRevision
        ItemRevision revision = itemBankMapper.map(itemBankItemRevision, currentGitInformation);

        revision = itemRevisionProcessor.applyRules(currentGitInformation, existingItem, revision);

        try {
            // Save to the DB
            itemRevisionService.save(revision);
        } catch (Exception e) {
            //Log item and project information.  By rethrowing the higher level error handler will log the Exception itself so we don't log it again here.
            throw new ItemIngestException(e, "Item id %s failed to save.  Revision %s", revision.getItem().getId(), itemBankItemRevision);
        }

        // Generate operational event for the item create/update
        generateItemEvent(currentGitInformation, revision);

        // Update our existing info to what we just saved
        return revision.getItemGitInformation();
    }

    /**
     * Generate an itemCreated or an itemUpdate event
     *
     * @param existingGitInfo used to determine if this is a create or an update
     * @param revision        ItemRevision that was created or updated
     */
    private void generateItemEvent(ItemGitInformation existingGitInfo, ItemRevision revision) {
        if (null == existingGitInfo) {
            logger.itemCreatedEvent(LOG, revision.getItem().getKey(),
                    revision.getItem().getId(), revision.getItemGitInformation().getProjectId());
        } else {
            logger.itemUpdatedEvent(LOG,
                    revision.getItem().getKey(),
                    revision.getItem().getId(),
                    revision.getItemGitInformation().getProjectId(),
                    revision.getItemGitInformation().getCurrentCommitHash());
        }
    }

    /**
     * Get the history of an item from the itembank
     *
     * @param itemBankId            the item bank id for the item.
     * @param currentGitInformation information about the last commit we processed for this item. May be null
     * @return an historical list of {@link ItemBankItemRevision} for the item that have occurred since the last revision processed,
     * or since the dawn of time if existingGitInfo is null.
     */
    private List<ItemBankCommit> getItemHistorySinceLastProcessed(int itemBankId, ItemGitInformation currentGitInformation) {
        // Get the history of the item from the item bank, going back to the last update
        // we processed, or the dawn of time if existingGitInfo is null
        List<ItemBankCommit> itemHistoryList = itemBankClient.getItemCommitHistory(itemBankId, currentGitInformation);

        // Generally the first item returned is the last one we processed. We could increase the since
        // time, but the granularity is seconds, and we want to be very sure we never miss a commit
        // so instead we will remove the first item from the list if we have already processed it
        if (itemHistoryList.size() > 0
                && currentGitInformation != null
                && itemHistoryList.get(0).getCommitHash().equals(currentGitInformation.getCurrentCommitHash())) {
            itemHistoryList.remove(0);
        }
        return itemHistoryList;
    }
}
