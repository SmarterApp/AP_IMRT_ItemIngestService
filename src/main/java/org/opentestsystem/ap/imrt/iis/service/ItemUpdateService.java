package org.opentestsystem.ap.imrt.iis.service;

import org.gitlab4j.api.models.RepositoryFile;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.model.ItemGitInformation;
import org.opentestsystem.ap.imrt.iis.model.ItemRevisionImpl;
import org.opentestsystem.ap.imrt.iis.repository.ItemGitInformationRepository;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.Base64;
import java.util.Optional;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 * <p>
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
@ConditionalOnProperty(value = "test.enabled", havingValue = "false", matchIfMissing = true)
public class ItemUpdateService {
    private static final Logger logger = LoggerFactory.getLogger(ItemUpdateService.class);

    private final ProjectLockService projectLockService;
    private final ItemBankClient itemBankClient;
    private final ItemParser itemUtil;
    private final DomainManager domainManager;
    private final ItemGitInformationRepository itemGitInformationRepository;
    private final OperationalEventService operationalEventService;

    public ItemUpdateService(ProjectLockService projectLockService, ItemBankClient itemBankClient,
                             ItemParser itemUtil, DomainManager domainManager,
                             ItemGitInformationRepository itemGitInformationRepository,
                             OperationalEventService operationalEventService) {
        this.projectLockService = projectLockService;
        this.itemBankClient = itemBankClient;
        this.itemUtil = itemUtil;
        this.domainManager = domainManager;
        this.itemGitInformationRepository = itemGitInformationRepository;
        this.operationalEventService = operationalEventService;
    }

    /**
     * This method is invoked to process messages on the item-update queue.
     * If the method returns normally, the message will be acked. If the method
     * throws an exception, the message will be requeued for later processing.
     *
     * @param itemId Unique item bank id for the item that has been updated.
     */
    @RabbitListener(queues = "item-update")
    public void updateItem(Integer itemId) {
        logger.debug("Received item update message for id {}", itemId);

        Optional<Long> lock = Optional.empty();

        // Lock the project first. Make sure we always unlock it in the finally clause
        try {
            lock = projectLockService.lockProject(itemId);
            if (!lock.isPresent()) {
                logger.debug("Project {} is already locked. Requeue message for later", itemId);
                throw new RuntimeException("Project is locked, requeue message");
            }
            // We got the lock, so process the update
            performItemUpdate(itemId);
        } finally {
            if (lock.isPresent()) {
                projectLockService.unlockProject(itemId, lock.get());
            }
        }
    }

    /**
     * Process an update for an item. Retrieve the lastest item.json for the item,
     * parse it, and write it to our repository.
     *
     * @param itemId Unique git id for the item to be processed.
     */
    private void performItemUpdate(int itemId) {
        try {
            // See if we can get a file. For now we will just grab latest on master
            Optional<RepositoryFile> itemFile = itemBankClient.getFile("item.json", itemId, "master");
            if (itemFile.isPresent()) {
                logger.debug("Retrieved item.json from gitlab commit id {}", itemFile.get().getLastCommitId());
                byte json[] = Base64.getDecoder().decode(itemFile.get().getContent());

                // This will throw a runtime exception if there is a problem converting the item
                Item item = itemUtil.readItem(json);

                // See if we have any existing itemGitInformation for this item in the database
                ItemGitInformation existingGitInfo = itemGitInformationRepository.findOne(itemId);

                // TODO use this to figure out which commits we have already processed and loop through any we haven't

                // TODO Once we have the commit details, update this call to include them - probably pass in an object
                // of some kind rather than these individual fields
                ItemRevisionImpl revision = new ItemRevisionImpl(item, itemId, "tbd git path", "tbd commit hash",
                        Instant.now(), "tbd author", existingGitInfo);

                domainManager.storeToDb(revision);
                //
            } else {
                logger.debug("No item.json is currently available for project id {}", itemId);
            }
        } catch (RuntimeException ex) {
            /*
             * Most exceptions that occur, such as errors parsing the json data coming from the item bank,
             * or unexpected content in the item, result in an exception, which results in a loop where we
             * throw, reque the message, only to have the same error occur again and again, spewing into the logs.
             * For now, let's catch them all until things are a bit more stable, and then see if we want to isolate a few we
             * might want to let bubble up for a message requeue. Anything we miss here will be retried by the sync
             * job as well.
             */
            operationalEventService.serviceError(logger, ex, "Unexpected exception while processing item {}", itemId);
        }
    }

}
