package org.opentestsystem.ap.imrt.iis.service;

import org.gitlab4j.api.models.RepositoryFile;
import org.opentestsystem.ap.common.model.Item;
import org.opentestsystem.ap.imrt.iis.client.ItemBankClient;
import org.opentestsystem.ap.imrt.iis.util.ItemParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.util.Base64;
import java.util.Optional;

/**
 * Service responsible for listening on the ite update queue and processing item update
 * messages. I'm not crazy about having to hardcode the queue name in the
 * annotation...
 *
 * Checking on the spring default configuration, it appears to be OK for the purpose of
 * creating a simple work queue. Acknowledgements will be sent automatically when the
 * listener completes processing. If it crashes or an exception is thrown, the message
 * will be requeued. In addition, a "fair" dispatching strategy is used, where messages
 * are kept on the queue until there is a free worker.
 */
@Service
@ConditionalOnProperty(value = "test.enabled", havingValue = "false", matchIfMissing = true)
public class ItemUpdateService {
    private static final Logger logger = LoggerFactory.getLogger(ItemUpdateService.class);

    private final ProjectLockService projectLockService;
    private final ItemBankClient itemBankClient;
    private final ItemParser itemUtil;

    public ItemUpdateService(ProjectLockService projectLockService, ItemBankClient itemBankClient,
                             ItemParser itemUtil) {
        this.projectLockService = projectLockService;
        this.itemBankClient = itemBankClient;
        this.itemUtil = itemUtil;
    }

    /**
     * This method is invoked to process messages on the item-update queue.
     * If the method returns normally, the message will be acked. If the method
     * throws an exception, the message will be requeued for later processing.
     * @param itemId  Unique item bank id for the item that has been updated.
     */
    @RabbitListener(queues = "item-update")
    public void processMessage(Integer itemId) {
        logger.debug("Received item update message for id {}", itemId);

        Optional<Long> lock = Optional.empty();

        // Lock the project first. Make sure we always unlock it in the finally clause
        try {
            lock = projectLockService.lockProject(itemId);
            if (!lock.isPresent()) {
                logger.debug("Project {} is already locked. Requeue message for later", itemId);
                throw new RuntimeException("Project is locked, requeue message");
            }
            // We got the lock, so process the update
            processItemUpdate(itemId);
        } finally {
            if (lock.isPresent()) {
                projectLockService.unlockProject(itemId, lock.get());
            }
        }
    }

    /**
     * Process an update for an item. Retrieve the lastest item.json for the item,
     * parse it, and write it to our repository.
     * @param itemId  Unique git id for the item to be processed.
     */
    private void processItemUpdate(int itemId) {
        // See if we can get a file. For now we will just grab latest on master
        Optional<RepositoryFile> itemFile = itemBankClient.getFile("item.json", itemId, "master");
        if (itemFile.isPresent()) {
            logger.debug("Retrieved item.json from gitlab commit id {}", itemFile.get().getLastCommitId());
            byte json[] = Base64.getDecoder().decode(itemFile.get().getContent());
            // This will throw a runtime exception if there is a problem converting the item
            Item item = itemUtil.readItem(json);
            logger.debug("converted item id {} type {}", item.getId(), item.getType());
            // TODO store to DB
        } else {
            logger.debug("No item.json is currently available for project id {}", itemId);
        }
    }

}
